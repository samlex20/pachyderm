// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: client/pfs/pfs.proto

package pfs

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	auth "github.com/pachyderm/pachyderm/src/client/auth"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// These are the different places where a commit may be originated from
type OriginKind int32

const (
	OriginKind_USER OriginKind = 0
	OriginKind_AUTO OriginKind = 1
	OriginKind_FSCK OriginKind = 2
)

var OriginKind_name = map[int32]string{
	0: "USER",
	1: "AUTO",
	2: "FSCK",
}

var OriginKind_value = map[string]int32{
	"USER": 0,
	"AUTO": 1,
	"FSCK": 2,
}

func (x OriginKind) String() string {
	return proto.EnumName(OriginKind_name, int32(x))
}

func (OriginKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{0}
}

type FileType int32

const (
	FileType_RESERVED FileType = 0
	FileType_FILE     FileType = 1
	FileType_DIR      FileType = 2
)

var FileType_name = map[int32]string{
	0: "RESERVED",
	1: "FILE",
	2: "DIR",
}

var FileType_value = map[string]int32{
	"RESERVED": 0,
	"FILE":     1,
	"DIR":      2,
}

func (x FileType) String() string {
	return proto.EnumName(FileType_name, int32(x))
}

func (FileType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{1}
}

// CommitState describes the states a commit can be in.
// The states are increasingly specific, i.e. a commit that is FINISHED also counts as STARTED.
type CommitState int32

const (
	CommitState_STARTED  CommitState = 0
	CommitState_READY    CommitState = 1
	CommitState_FINISHED CommitState = 2
)

var CommitState_name = map[int32]string{
	0: "STARTED",
	1: "READY",
	2: "FINISHED",
}

var CommitState_value = map[string]int32{
	"STARTED":  0,
	"READY":    1,
	"FINISHED": 2,
}

func (x CommitState) String() string {
	return proto.EnumName(CommitState_name, int32(x))
}

func (CommitState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{2}
}

type Delimiter int32

const (
	Delimiter_NONE Delimiter = 0
	Delimiter_JSON Delimiter = 1
	Delimiter_LINE Delimiter = 2
	Delimiter_SQL  Delimiter = 3
	Delimiter_CSV  Delimiter = 4
)

var Delimiter_name = map[int32]string{
	0: "NONE",
	1: "JSON",
	2: "LINE",
	3: "SQL",
	4: "CSV",
}

var Delimiter_value = map[string]int32{
	"NONE": 0,
	"JSON": 1,
	"LINE": 2,
	"SQL":  3,
	"CSV":  4,
}

func (x Delimiter) String() string {
	return proto.EnumName(Delimiter_name, int32(x))
}

func (Delimiter) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{3}
}

type Repo struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Repo) Reset()         { *m = Repo{} }
func (m *Repo) String() string { return proto.CompactTextString(m) }
func (*Repo) ProtoMessage()    {}
func (*Repo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{0}
}
func (m *Repo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Repo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Repo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Repo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Repo.Merge(m, src)
}
func (m *Repo) XXX_Size() int {
	return m.Size()
}
func (m *Repo) XXX_DiscardUnknown() {
	xxx_messageInfo_Repo.DiscardUnknown(m)
}

var xxx_messageInfo_Repo proto.InternalMessageInfo

func (m *Repo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Branch struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Branch) Reset()         { *m = Branch{} }
func (m *Branch) String() string { return proto.CompactTextString(m) }
func (*Branch) ProtoMessage()    {}
func (*Branch) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{1}
}
func (m *Branch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Branch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Branch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Branch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Branch.Merge(m, src)
}
func (m *Branch) XXX_Size() int {
	return m.Size()
}
func (m *Branch) XXX_DiscardUnknown() {
	xxx_messageInfo_Branch.DiscardUnknown(m)
}

var xxx_messageInfo_Branch proto.InternalMessageInfo

func (m *Branch) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *Branch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type BranchInfo struct {
	Branch           *Branch   `protobuf:"bytes,4,opt,name=branch,proto3" json:"branch,omitempty"`
	Head             *Commit   `protobuf:"bytes,2,opt,name=head,proto3" json:"head,omitempty"`
	Provenance       []*Branch `protobuf:"bytes,3,rep,name=provenance,proto3" json:"provenance,omitempty"`
	Subvenance       []*Branch `protobuf:"bytes,5,rep,name=subvenance,proto3" json:"subvenance,omitempty"`
	DirectProvenance []*Branch `protobuf:"bytes,6,rep,name=direct_provenance,json=directProvenance,proto3" json:"direct_provenance,omitempty"`
	// Deprecated field left for backward compatibility.
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BranchInfo) Reset()         { *m = BranchInfo{} }
func (m *BranchInfo) String() string { return proto.CompactTextString(m) }
func (*BranchInfo) ProtoMessage()    {}
func (*BranchInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{2}
}
func (m *BranchInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BranchInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BranchInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BranchInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BranchInfo.Merge(m, src)
}
func (m *BranchInfo) XXX_Size() int {
	return m.Size()
}
func (m *BranchInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BranchInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BranchInfo proto.InternalMessageInfo

func (m *BranchInfo) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *BranchInfo) GetHead() *Commit {
	if m != nil {
		return m.Head
	}
	return nil
}

func (m *BranchInfo) GetProvenance() []*Branch {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *BranchInfo) GetSubvenance() []*Branch {
	if m != nil {
		return m.Subvenance
	}
	return nil
}

func (m *BranchInfo) GetDirectProvenance() []*Branch {
	if m != nil {
		return m.DirectProvenance
	}
	return nil
}

func (m *BranchInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type BranchInfos struct {
	BranchInfo           []*BranchInfo `protobuf:"bytes,1,rep,name=branch_info,json=branchInfo,proto3" json:"branch_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *BranchInfos) Reset()         { *m = BranchInfos{} }
func (m *BranchInfos) String() string { return proto.CompactTextString(m) }
func (*BranchInfos) ProtoMessage()    {}
func (*BranchInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{3}
}
func (m *BranchInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BranchInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BranchInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BranchInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BranchInfos.Merge(m, src)
}
func (m *BranchInfos) XXX_Size() int {
	return m.Size()
}
func (m *BranchInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_BranchInfos.DiscardUnknown(m)
}

var xxx_messageInfo_BranchInfos proto.InternalMessageInfo

func (m *BranchInfos) GetBranchInfo() []*BranchInfo {
	if m != nil {
		return m.BranchInfo
	}
	return nil
}

type File struct {
	Commit               *Commit  `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	Path                 string   `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *File) Reset()         { *m = File{} }
func (m *File) String() string { return proto.CompactTextString(m) }
func (*File) ProtoMessage()    {}
func (*File) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{4}
}
func (m *File) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_File.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_File.Merge(m, src)
}
func (m *File) XXX_Size() int {
	return m.Size()
}
func (m *File) XXX_DiscardUnknown() {
	xxx_messageInfo_File.DiscardUnknown(m)
}

var xxx_messageInfo_File proto.InternalMessageInfo

func (m *File) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *File) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type Block struct {
	Hash                 string   `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Block) Reset()         { *m = Block{} }
func (m *Block) String() string { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()    {}
func (*Block) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{5}
}
func (m *Block) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block.Merge(m, src)
}
func (m *Block) XXX_Size() int {
	return m.Size()
}
func (m *Block) XXX_DiscardUnknown() {
	xxx_messageInfo_Block.DiscardUnknown(m)
}

var xxx_messageInfo_Block proto.InternalMessageInfo

func (m *Block) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type Object struct {
	Hash                 string   `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Object) Reset()         { *m = Object{} }
func (m *Object) String() string { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()    {}
func (*Object) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{6}
}
func (m *Object) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Object.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Object) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Object.Merge(m, src)
}
func (m *Object) XXX_Size() int {
	return m.Size()
}
func (m *Object) XXX_DiscardUnknown() {
	xxx_messageInfo_Object.DiscardUnknown(m)
}

var xxx_messageInfo_Object proto.InternalMessageInfo

func (m *Object) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type Tag struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tag) Reset()         { *m = Tag{} }
func (m *Tag) String() string { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()    {}
func (*Tag) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{7}
}
func (m *Tag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tag.Merge(m, src)
}
func (m *Tag) XXX_Size() int {
	return m.Size()
}
func (m *Tag) XXX_DiscardUnknown() {
	xxx_messageInfo_Tag.DiscardUnknown(m)
}

var xxx_messageInfo_Tag proto.InternalMessageInfo

func (m *Tag) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// RepoInfo is the main data structure representing a Repo in etcd
type RepoInfo struct {
	Repo        *Repo            `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Created     *types.Timestamp `protobuf:"bytes,2,opt,name=created,proto3" json:"created,omitempty"`
	SizeBytes   uint64           `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Description string           `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Branches    []*Branch        `protobuf:"bytes,7,rep,name=branches,proto3" json:"branches,omitempty"`
	// Set by ListRepo and InspectRepo if Pachyderm's auth system is active, but
	// not stored in etcd. To set a user's auth scope for a repo, use the
	// Pachyderm Auth API (in src/client/auth/auth.proto)
	AuthInfo             *RepoAuthInfo `protobuf:"bytes,6,opt,name=auth_info,json=authInfo,proto3" json:"auth_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RepoInfo) Reset()         { *m = RepoInfo{} }
func (m *RepoInfo) String() string { return proto.CompactTextString(m) }
func (*RepoInfo) ProtoMessage()    {}
func (*RepoInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{8}
}
func (m *RepoInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepoInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepoInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepoInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepoInfo.Merge(m, src)
}
func (m *RepoInfo) XXX_Size() int {
	return m.Size()
}
func (m *RepoInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RepoInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RepoInfo proto.InternalMessageInfo

func (m *RepoInfo) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *RepoInfo) GetCreated() *types.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *RepoInfo) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *RepoInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RepoInfo) GetBranches() []*Branch {
	if m != nil {
		return m.Branches
	}
	return nil
}

func (m *RepoInfo) GetAuthInfo() *RepoAuthInfo {
	if m != nil {
		return m.AuthInfo
	}
	return nil
}

// RepoAuthInfo includes the caller's access scope for a repo, and is returned
// by ListRepo and InspectRepo but not persisted in etcd. It's used by the
// Pachyderm dashboard to render repo access appropriately. To set a user's auth
// scope for a repo, use the Pachyderm Auth API (in src/client/auth/auth.proto)
type RepoAuthInfo struct {
	// The callers access level to the relevant repo (e.g. may be OWNER even if
	// the user isn't an OWNER of the repo, if they're an admin for the cluster)
	AccessLevel          auth.Scope `protobuf:"varint,1,opt,name=access_level,json=accessLevel,proto3,enum=auth.Scope" json:"access_level,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RepoAuthInfo) Reset()         { *m = RepoAuthInfo{} }
func (m *RepoAuthInfo) String() string { return proto.CompactTextString(m) }
func (*RepoAuthInfo) ProtoMessage()    {}
func (*RepoAuthInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{9}
}
func (m *RepoAuthInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepoAuthInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepoAuthInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepoAuthInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepoAuthInfo.Merge(m, src)
}
func (m *RepoAuthInfo) XXX_Size() int {
	return m.Size()
}
func (m *RepoAuthInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RepoAuthInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RepoAuthInfo proto.InternalMessageInfo

func (m *RepoAuthInfo) GetAccessLevel() auth.Scope {
	if m != nil {
		return m.AccessLevel
	}
	return auth.Scope_NONE
}

type CommitOrigin struct {
	Kind                 OriginKind `protobuf:"varint,1,opt,name=kind,proto3,enum=pfs.OriginKind" json:"kind,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CommitOrigin) Reset()         { *m = CommitOrigin{} }
func (m *CommitOrigin) String() string { return proto.CompactTextString(m) }
func (*CommitOrigin) ProtoMessage()    {}
func (*CommitOrigin) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{10}
}
func (m *CommitOrigin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitOrigin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitOrigin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitOrigin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitOrigin.Merge(m, src)
}
func (m *CommitOrigin) XXX_Size() int {
	return m.Size()
}
func (m *CommitOrigin) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitOrigin.DiscardUnknown(m)
}

var xxx_messageInfo_CommitOrigin proto.InternalMessageInfo

func (m *CommitOrigin) GetKind() OriginKind {
	if m != nil {
		return m.Kind
	}
	return OriginKind_USER
}

// Commit is a reference to a commit (e.g. the collection of branches and the
// collection of currently-open commits in etcd are collections of Commit
// protos)
type Commit struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	ID                   string   `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Commit) Reset()         { *m = Commit{} }
func (m *Commit) String() string { return proto.CompactTextString(m) }
func (*Commit) ProtoMessage()    {}
func (*Commit) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{11}
}
func (m *Commit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Commit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Commit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Commit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Commit.Merge(m, src)
}
func (m *Commit) XXX_Size() int {
	return m.Size()
}
func (m *Commit) XXX_DiscardUnknown() {
	xxx_messageInfo_Commit.DiscardUnknown(m)
}

var xxx_messageInfo_Commit proto.InternalMessageInfo

func (m *Commit) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *Commit) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

// CommitRange represents chain of commits with Lower being an ancestor of
// Upper or, in the case of a range of size 1, the same commit.
type CommitRange struct {
	Lower                *Commit  `protobuf:"bytes,1,opt,name=lower,proto3" json:"lower,omitempty"`
	Upper                *Commit  `protobuf:"bytes,2,opt,name=upper,proto3" json:"upper,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommitRange) Reset()         { *m = CommitRange{} }
func (m *CommitRange) String() string { return proto.CompactTextString(m) }
func (*CommitRange) ProtoMessage()    {}
func (*CommitRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{12}
}
func (m *CommitRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitRange.Merge(m, src)
}
func (m *CommitRange) XXX_Size() int {
	return m.Size()
}
func (m *CommitRange) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitRange.DiscardUnknown(m)
}

var xxx_messageInfo_CommitRange proto.InternalMessageInfo

func (m *CommitRange) GetLower() *Commit {
	if m != nil {
		return m.Lower
	}
	return nil
}

func (m *CommitRange) GetUpper() *Commit {
	if m != nil {
		return m.Upper
	}
	return nil
}

// CommitProvenance keeps track of where (i.e. which branch) a certain commit
// originated from. A commit's provenance consists of the commits of
// the commits which are in its causal history.
type CommitProvenance struct {
	Commit               *Commit  `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	Branch               *Branch  `protobuf:"bytes,2,opt,name=branch,proto3" json:"branch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommitProvenance) Reset()         { *m = CommitProvenance{} }
func (m *CommitProvenance) String() string { return proto.CompactTextString(m) }
func (*CommitProvenance) ProtoMessage()    {}
func (*CommitProvenance) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{13}
}
func (m *CommitProvenance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitProvenance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitProvenance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitProvenance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitProvenance.Merge(m, src)
}
func (m *CommitProvenance) XXX_Size() int {
	return m.Size()
}
func (m *CommitProvenance) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitProvenance.DiscardUnknown(m)
}

var xxx_messageInfo_CommitProvenance proto.InternalMessageInfo

func (m *CommitProvenance) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *CommitProvenance) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

// CommitInfo is the main data structure representing a commit in etcd
type CommitInfo struct {
	Commit *Commit       `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	Branch *Branch       `protobuf:"bytes,15,opt,name=branch,proto3" json:"branch,omitempty"`
	Origin *CommitOrigin `protobuf:"bytes,17,opt,name=origin,proto3" json:"origin,omitempty"`
	// description is a user-provided script describing this commit
	Description  string           `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
	ParentCommit *Commit          `protobuf:"bytes,2,opt,name=parent_commit,json=parentCommit,proto3" json:"parent_commit,omitempty"`
	ChildCommits []*Commit        `protobuf:"bytes,11,rep,name=child_commits,json=childCommits,proto3" json:"child_commits,omitempty"`
	Started      *types.Timestamp `protobuf:"bytes,3,opt,name=started,proto3" json:"started,omitempty"`
	Finished     *types.Timestamp `protobuf:"bytes,4,opt,name=finished,proto3" json:"finished,omitempty"`
	SizeBytes    uint64           `protobuf:"varint,5,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// the commits and their original branches on which this commit is provenant
	Provenance []*CommitProvenance `protobuf:"bytes,16,rep,name=provenance,proto3" json:"provenance,omitempty"`
	// ReadyProvenance is the number of provenant commits which have been
	// finished, if ReadyProvenance == len(Provenance) then the commit is ready
	// to be processed by pps.
	ReadyProvenance int64          `protobuf:"varint,12,opt,name=ready_provenance,json=readyProvenance,proto3" json:"ready_provenance,omitempty"`
	Subvenance      []*CommitRange `protobuf:"bytes,9,rep,name=subvenance,proto3" json:"subvenance,omitempty"`
	// this is the block that stores the serialized form of a tree that
	// represents the entire file system hierarchy of the repo at this commit
	// If this is nil, then the commit is either open (in which case 'finished'
	// will also be nil) or is the output commit of a failed job (in which case
	// 'finished' will have a value -- the end time of the job)
	Tree                    *Object   `protobuf:"bytes,7,opt,name=tree,proto3" json:"tree,omitempty"`
	Trees                   []*Object `protobuf:"bytes,13,rep,name=trees,proto3" json:"trees,omitempty"`
	Datums                  *Object   `protobuf:"bytes,14,opt,name=datums,proto3" json:"datums,omitempty"`
	SubvenantCommitsSuccess int64     `protobuf:"varint,18,opt,name=subvenant_commits_success,json=subvenantCommitsSuccess,proto3" json:"subvenant_commits_success,omitempty"`
	SubvenantCommitsFailure int64     `protobuf:"varint,19,opt,name=subvenant_commits_failure,json=subvenantCommitsFailure,proto3" json:"subvenant_commits_failure,omitempty"`
	SubvenantCommitsTotal   int64     `protobuf:"varint,20,opt,name=subvenant_commits_total,json=subvenantCommitsTotal,proto3" json:"subvenant_commits_total,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}  `json:"-"`
	XXX_unrecognized        []byte    `json:"-"`
	XXX_sizecache           int32     `json:"-"`
}

func (m *CommitInfo) Reset()         { *m = CommitInfo{} }
func (m *CommitInfo) String() string { return proto.CompactTextString(m) }
func (*CommitInfo) ProtoMessage()    {}
func (*CommitInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{14}
}
func (m *CommitInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitInfo.Merge(m, src)
}
func (m *CommitInfo) XXX_Size() int {
	return m.Size()
}
func (m *CommitInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CommitInfo proto.InternalMessageInfo

func (m *CommitInfo) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *CommitInfo) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *CommitInfo) GetOrigin() *CommitOrigin {
	if m != nil {
		return m.Origin
	}
	return nil
}

func (m *CommitInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CommitInfo) GetParentCommit() *Commit {
	if m != nil {
		return m.ParentCommit
	}
	return nil
}

func (m *CommitInfo) GetChildCommits() []*Commit {
	if m != nil {
		return m.ChildCommits
	}
	return nil
}

func (m *CommitInfo) GetStarted() *types.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *CommitInfo) GetFinished() *types.Timestamp {
	if m != nil {
		return m.Finished
	}
	return nil
}

func (m *CommitInfo) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *CommitInfo) GetProvenance() []*CommitProvenance {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *CommitInfo) GetReadyProvenance() int64 {
	if m != nil {
		return m.ReadyProvenance
	}
	return 0
}

func (m *CommitInfo) GetSubvenance() []*CommitRange {
	if m != nil {
		return m.Subvenance
	}
	return nil
}

func (m *CommitInfo) GetTree() *Object {
	if m != nil {
		return m.Tree
	}
	return nil
}

func (m *CommitInfo) GetTrees() []*Object {
	if m != nil {
		return m.Trees
	}
	return nil
}

func (m *CommitInfo) GetDatums() *Object {
	if m != nil {
		return m.Datums
	}
	return nil
}

func (m *CommitInfo) GetSubvenantCommitsSuccess() int64 {
	if m != nil {
		return m.SubvenantCommitsSuccess
	}
	return 0
}

func (m *CommitInfo) GetSubvenantCommitsFailure() int64 {
	if m != nil {
		return m.SubvenantCommitsFailure
	}
	return 0
}

func (m *CommitInfo) GetSubvenantCommitsTotal() int64 {
	if m != nil {
		return m.SubvenantCommitsTotal
	}
	return 0
}

type FileInfo struct {
	File      *File            `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	FileType  FileType         `protobuf:"varint,2,opt,name=file_type,json=fileType,proto3,enum=pfs.FileType" json:"file_type,omitempty"`
	SizeBytes uint64           `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Committed *types.Timestamp `protobuf:"bytes,10,opt,name=committed,proto3" json:"committed,omitempty"`
	// the base names (i.e. just the filenames, not the full paths) of
	// the children
	Children             []string    `protobuf:"bytes,6,rep,name=children,proto3" json:"children,omitempty"`
	Objects              []*Object   `protobuf:"bytes,8,rep,name=objects,proto3" json:"objects,omitempty"`
	BlockRefs            []*BlockRef `protobuf:"bytes,9,rep,name=blockRefs,proto3" json:"blockRefs,omitempty"`
	Hash                 []byte      `protobuf:"bytes,7,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *FileInfo) Reset()         { *m = FileInfo{} }
func (m *FileInfo) String() string { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()    {}
func (*FileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{15}
}
func (m *FileInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileInfo.Merge(m, src)
}
func (m *FileInfo) XXX_Size() int {
	return m.Size()
}
func (m *FileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FileInfo proto.InternalMessageInfo

func (m *FileInfo) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *FileInfo) GetFileType() FileType {
	if m != nil {
		return m.FileType
	}
	return FileType_RESERVED
}

func (m *FileInfo) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *FileInfo) GetCommitted() *types.Timestamp {
	if m != nil {
		return m.Committed
	}
	return nil
}

func (m *FileInfo) GetChildren() []string {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *FileInfo) GetObjects() []*Object {
	if m != nil {
		return m.Objects
	}
	return nil
}

func (m *FileInfo) GetBlockRefs() []*BlockRef {
	if m != nil {
		return m.BlockRefs
	}
	return nil
}

func (m *FileInfo) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type ByteRange struct {
	Lower                uint64   `protobuf:"varint,1,opt,name=lower,proto3" json:"lower,omitempty"`
	Upper                uint64   `protobuf:"varint,2,opt,name=upper,proto3" json:"upper,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ByteRange) Reset()         { *m = ByteRange{} }
func (m *ByteRange) String() string { return proto.CompactTextString(m) }
func (*ByteRange) ProtoMessage()    {}
func (*ByteRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{16}
}
func (m *ByteRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ByteRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ByteRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ByteRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ByteRange.Merge(m, src)
}
func (m *ByteRange) XXX_Size() int {
	return m.Size()
}
func (m *ByteRange) XXX_DiscardUnknown() {
	xxx_messageInfo_ByteRange.DiscardUnknown(m)
}

var xxx_messageInfo_ByteRange proto.InternalMessageInfo

func (m *ByteRange) GetLower() uint64 {
	if m != nil {
		return m.Lower
	}
	return 0
}

func (m *ByteRange) GetUpper() uint64 {
	if m != nil {
		return m.Upper
	}
	return 0
}

type BlockRef struct {
	Block                *Block     `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
	Range                *ByteRange `protobuf:"bytes,2,opt,name=range,proto3" json:"range,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BlockRef) Reset()         { *m = BlockRef{} }
func (m *BlockRef) String() string { return proto.CompactTextString(m) }
func (*BlockRef) ProtoMessage()    {}
func (*BlockRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{17}
}
func (m *BlockRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockRef.Merge(m, src)
}
func (m *BlockRef) XXX_Size() int {
	return m.Size()
}
func (m *BlockRef) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockRef.DiscardUnknown(m)
}

var xxx_messageInfo_BlockRef proto.InternalMessageInfo

func (m *BlockRef) GetBlock() *Block {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *BlockRef) GetRange() *ByteRange {
	if m != nil {
		return m.Range
	}
	return nil
}

type ObjectInfo struct {
	Object               *Object   `protobuf:"bytes,1,opt,name=object,proto3" json:"object,omitempty"`
	BlockRef             *BlockRef `protobuf:"bytes,2,opt,name=block_ref,json=blockRef,proto3" json:"block_ref,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ObjectInfo) Reset()         { *m = ObjectInfo{} }
func (m *ObjectInfo) String() string { return proto.CompactTextString(m) }
func (*ObjectInfo) ProtoMessage()    {}
func (*ObjectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{18}
}
func (m *ObjectInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectInfo.Merge(m, src)
}
func (m *ObjectInfo) XXX_Size() int {
	return m.Size()
}
func (m *ObjectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectInfo proto.InternalMessageInfo

func (m *ObjectInfo) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *ObjectInfo) GetBlockRef() *BlockRef {
	if m != nil {
		return m.BlockRef
	}
	return nil
}

type Compaction struct {
	InputPrefixes        []string `protobuf:"bytes,2,rep,name=input_prefixes,json=inputPrefixes,proto3" json:"input_prefixes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Compaction) Reset()         { *m = Compaction{} }
func (m *Compaction) String() string { return proto.CompactTextString(m) }
func (*Compaction) ProtoMessage()    {}
func (*Compaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{19}
}
func (m *Compaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Compaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Compaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Compaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Compaction.Merge(m, src)
}
func (m *Compaction) XXX_Size() int {
	return m.Size()
}
func (m *Compaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Compaction.DiscardUnknown(m)
}

var xxx_messageInfo_Compaction proto.InternalMessageInfo

func (m *Compaction) GetInputPrefixes() []string {
	if m != nil {
		return m.InputPrefixes
	}
	return nil
}

type Shard struct {
	Compaction           *Compaction `protobuf:"bytes,1,opt,name=compaction,proto3" json:"compaction,omitempty"`
	Range                *PathRange  `protobuf:"bytes,2,opt,name=range,proto3" json:"range,omitempty"`
	OutputPath           string      `protobuf:"bytes,3,opt,name=output_path,json=outputPath,proto3" json:"output_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Shard) Reset()         { *m = Shard{} }
func (m *Shard) String() string { return proto.CompactTextString(m) }
func (*Shard) ProtoMessage()    {}
func (*Shard) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{20}
}
func (m *Shard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Shard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Shard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Shard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Shard.Merge(m, src)
}
func (m *Shard) XXX_Size() int {
	return m.Size()
}
func (m *Shard) XXX_DiscardUnknown() {
	xxx_messageInfo_Shard.DiscardUnknown(m)
}

var xxx_messageInfo_Shard proto.InternalMessageInfo

func (m *Shard) GetCompaction() *Compaction {
	if m != nil {
		return m.Compaction
	}
	return nil
}

func (m *Shard) GetRange() *PathRange {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *Shard) GetOutputPath() string {
	if m != nil {
		return m.OutputPath
	}
	return ""
}

type PathRange struct {
	Lower                string   `protobuf:"bytes,1,opt,name=lower,proto3" json:"lower,omitempty"`
	Upper                string   `protobuf:"bytes,2,opt,name=upper,proto3" json:"upper,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PathRange) Reset()         { *m = PathRange{} }
func (m *PathRange) String() string { return proto.CompactTextString(m) }
func (*PathRange) ProtoMessage()    {}
func (*PathRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{21}
}
func (m *PathRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PathRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathRange.Merge(m, src)
}
func (m *PathRange) XXX_Size() int {
	return m.Size()
}
func (m *PathRange) XXX_DiscardUnknown() {
	xxx_messageInfo_PathRange.DiscardUnknown(m)
}

var xxx_messageInfo_PathRange proto.InternalMessageInfo

func (m *PathRange) GetLower() string {
	if m != nil {
		return m.Lower
	}
	return ""
}

func (m *PathRange) GetUpper() string {
	if m != nil {
		return m.Upper
	}
	return ""
}

type CreateRepoRequest struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Description          string   `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Update               bool     `protobuf:"varint,4,opt,name=update,proto3" json:"update,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateRepoRequest) Reset()         { *m = CreateRepoRequest{} }
func (m *CreateRepoRequest) String() string { return proto.CompactTextString(m) }
func (*CreateRepoRequest) ProtoMessage()    {}
func (*CreateRepoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{22}
}
func (m *CreateRepoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateRepoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateRepoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateRepoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateRepoRequest.Merge(m, src)
}
func (m *CreateRepoRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateRepoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateRepoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateRepoRequest proto.InternalMessageInfo

func (m *CreateRepoRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *CreateRepoRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateRepoRequest) GetUpdate() bool {
	if m != nil {
		return m.Update
	}
	return false
}

type InspectRepoRequest struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectRepoRequest) Reset()         { *m = InspectRepoRequest{} }
func (m *InspectRepoRequest) String() string { return proto.CompactTextString(m) }
func (*InspectRepoRequest) ProtoMessage()    {}
func (*InspectRepoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{23}
}
func (m *InspectRepoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectRepoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectRepoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectRepoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectRepoRequest.Merge(m, src)
}
func (m *InspectRepoRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectRepoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectRepoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectRepoRequest proto.InternalMessageInfo

func (m *InspectRepoRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

type ListRepoRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListRepoRequest) Reset()         { *m = ListRepoRequest{} }
func (m *ListRepoRequest) String() string { return proto.CompactTextString(m) }
func (*ListRepoRequest) ProtoMessage()    {}
func (*ListRepoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{24}
}
func (m *ListRepoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRepoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRepoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRepoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRepoRequest.Merge(m, src)
}
func (m *ListRepoRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListRepoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRepoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRepoRequest proto.InternalMessageInfo

type ListRepoResponse struct {
	RepoInfo             []*RepoInfo `protobuf:"bytes,1,rep,name=repo_info,json=repoInfo,proto3" json:"repo_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ListRepoResponse) Reset()         { *m = ListRepoResponse{} }
func (m *ListRepoResponse) String() string { return proto.CompactTextString(m) }
func (*ListRepoResponse) ProtoMessage()    {}
func (*ListRepoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{25}
}
func (m *ListRepoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRepoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRepoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRepoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRepoResponse.Merge(m, src)
}
func (m *ListRepoResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListRepoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRepoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListRepoResponse proto.InternalMessageInfo

func (m *ListRepoResponse) GetRepoInfo() []*RepoInfo {
	if m != nil {
		return m.RepoInfo
	}
	return nil
}

type DeleteRepoRequest struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Force                bool     `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	All                  bool     `protobuf:"varint,3,opt,name=all,proto3" json:"all,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteRepoRequest) Reset()         { *m = DeleteRepoRequest{} }
func (m *DeleteRepoRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRepoRequest) ProtoMessage()    {}
func (*DeleteRepoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{26}
}
func (m *DeleteRepoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRepoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteRepoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteRepoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRepoRequest.Merge(m, src)
}
func (m *DeleteRepoRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRepoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRepoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRepoRequest proto.InternalMessageInfo

func (m *DeleteRepoRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *DeleteRepoRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *DeleteRepoRequest) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

type StartCommitRequest struct {
	// Parent.ID may be empty in which case the commit that Branch points to will be used as the parent.
	// If branch is empty, or if branch does not exist, the commit will have no parent.
	Parent *Commit `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// description is a user-provided string describing this commit
	Description          string              `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Branch               string              `protobuf:"bytes,3,opt,name=branch,proto3" json:"branch,omitempty"`
	Provenance           []*CommitProvenance `protobuf:"bytes,5,rep,name=provenance,proto3" json:"provenance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *StartCommitRequest) Reset()         { *m = StartCommitRequest{} }
func (m *StartCommitRequest) String() string { return proto.CompactTextString(m) }
func (*StartCommitRequest) ProtoMessage()    {}
func (*StartCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{27}
}
func (m *StartCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartCommitRequest.Merge(m, src)
}
func (m *StartCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartCommitRequest proto.InternalMessageInfo

func (m *StartCommitRequest) GetParent() *Commit {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *StartCommitRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *StartCommitRequest) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *StartCommitRequest) GetProvenance() []*CommitProvenance {
	if m != nil {
		return m.Provenance
	}
	return nil
}

type BuildCommitRequest struct {
	Parent     *Commit             `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	Branch     string              `protobuf:"bytes,4,opt,name=branch,proto3" json:"branch,omitempty"`
	Provenance []*CommitProvenance `protobuf:"bytes,6,rep,name=provenance,proto3" json:"provenance,omitempty"`
	Tree       *Object             `protobuf:"bytes,3,opt,name=tree,proto3" json:"tree,omitempty"`
	Trees      []*Object           `protobuf:"bytes,7,rep,name=trees,proto3" json:"trees,omitempty"`
	Datums     *Object             `protobuf:"bytes,8,opt,name=datums,proto3" json:"datums,omitempty"`
	// ID sets the ID of the created commit.
	ID        string `protobuf:"bytes,5,opt,name=ID,proto3" json:"ID,omitempty"`
	SizeBytes uint64 `protobuf:"varint,9,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// 'started' and 'finished' are set by Restore() when repopulating old
	// commits. If 'finished' is set, the commit being built is always marked
	// finished.
	Started              *types.Timestamp `protobuf:"bytes,10,opt,name=started,proto3" json:"started,omitempty"`
	Finished             *types.Timestamp `protobuf:"bytes,11,opt,name=finished,proto3" json:"finished,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *BuildCommitRequest) Reset()         { *m = BuildCommitRequest{} }
func (m *BuildCommitRequest) String() string { return proto.CompactTextString(m) }
func (*BuildCommitRequest) ProtoMessage()    {}
func (*BuildCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{28}
}
func (m *BuildCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildCommitRequest.Merge(m, src)
}
func (m *BuildCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *BuildCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BuildCommitRequest proto.InternalMessageInfo

func (m *BuildCommitRequest) GetParent() *Commit {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *BuildCommitRequest) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *BuildCommitRequest) GetProvenance() []*CommitProvenance {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *BuildCommitRequest) GetTree() *Object {
	if m != nil {
		return m.Tree
	}
	return nil
}

func (m *BuildCommitRequest) GetTrees() []*Object {
	if m != nil {
		return m.Trees
	}
	return nil
}

func (m *BuildCommitRequest) GetDatums() *Object {
	if m != nil {
		return m.Datums
	}
	return nil
}

func (m *BuildCommitRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *BuildCommitRequest) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *BuildCommitRequest) GetStarted() *types.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *BuildCommitRequest) GetFinished() *types.Timestamp {
	if m != nil {
		return m.Finished
	}
	return nil
}

type FinishCommitRequest struct {
	Commit *Commit `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	// description is a user-provided string describing this commit. Setting this
	// will overwrite the description set in StartCommit
	Description string    `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Tree        *Object   `protobuf:"bytes,3,opt,name=tree,proto3" json:"tree,omitempty"`
	Trees       []*Object `protobuf:"bytes,5,rep,name=trees,proto3" json:"trees,omitempty"`
	Datums      *Object   `protobuf:"bytes,7,opt,name=datums,proto3" json:"datums,omitempty"`
	SizeBytes   uint64    `protobuf:"varint,6,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// If set, 'commit' will be closed (its 'finished' field will be set to the
	// current time) but its 'tree' will be left nil.
	Empty                bool     `protobuf:"varint,4,opt,name=empty,proto3" json:"empty,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FinishCommitRequest) Reset()         { *m = FinishCommitRequest{} }
func (m *FinishCommitRequest) String() string { return proto.CompactTextString(m) }
func (*FinishCommitRequest) ProtoMessage()    {}
func (*FinishCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{29}
}
func (m *FinishCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinishCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinishCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinishCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinishCommitRequest.Merge(m, src)
}
func (m *FinishCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *FinishCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FinishCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FinishCommitRequest proto.InternalMessageInfo

func (m *FinishCommitRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *FinishCommitRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *FinishCommitRequest) GetTree() *Object {
	if m != nil {
		return m.Tree
	}
	return nil
}

func (m *FinishCommitRequest) GetTrees() []*Object {
	if m != nil {
		return m.Trees
	}
	return nil
}

func (m *FinishCommitRequest) GetDatums() *Object {
	if m != nil {
		return m.Datums
	}
	return nil
}

func (m *FinishCommitRequest) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *FinishCommitRequest) GetEmpty() bool {
	if m != nil {
		return m.Empty
	}
	return false
}

type InspectCommitRequest struct {
	Commit *Commit `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	// BlockState causes inspect commit to block until the commit is in the desired state.
	BlockState           CommitState `protobuf:"varint,2,opt,name=block_state,json=blockState,proto3,enum=pfs.CommitState" json:"block_state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *InspectCommitRequest) Reset()         { *m = InspectCommitRequest{} }
func (m *InspectCommitRequest) String() string { return proto.CompactTextString(m) }
func (*InspectCommitRequest) ProtoMessage()    {}
func (*InspectCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{30}
}
func (m *InspectCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectCommitRequest.Merge(m, src)
}
func (m *InspectCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectCommitRequest proto.InternalMessageInfo

func (m *InspectCommitRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *InspectCommitRequest) GetBlockState() CommitState {
	if m != nil {
		return m.BlockState
	}
	return CommitState_STARTED
}

type ListCommitRequest struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	From                 *Commit  `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	To                   *Commit  `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	Number               uint64   `protobuf:"varint,4,opt,name=number,proto3" json:"number,omitempty"`
	Reverse              bool     `protobuf:"varint,5,opt,name=reverse,proto3" json:"reverse,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListCommitRequest) Reset()         { *m = ListCommitRequest{} }
func (m *ListCommitRequest) String() string { return proto.CompactTextString(m) }
func (*ListCommitRequest) ProtoMessage()    {}
func (*ListCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{31}
}
func (m *ListCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCommitRequest.Merge(m, src)
}
func (m *ListCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListCommitRequest proto.InternalMessageInfo

func (m *ListCommitRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *ListCommitRequest) GetFrom() *Commit {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *ListCommitRequest) GetTo() *Commit {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *ListCommitRequest) GetNumber() uint64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *ListCommitRequest) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

type CommitInfos struct {
	CommitInfo           []*CommitInfo `protobuf:"bytes,1,rep,name=commit_info,json=commitInfo,proto3" json:"commit_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CommitInfos) Reset()         { *m = CommitInfos{} }
func (m *CommitInfos) String() string { return proto.CompactTextString(m) }
func (*CommitInfos) ProtoMessage()    {}
func (*CommitInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{32}
}
func (m *CommitInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitInfos.Merge(m, src)
}
func (m *CommitInfos) XXX_Size() int {
	return m.Size()
}
func (m *CommitInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitInfos.DiscardUnknown(m)
}

var xxx_messageInfo_CommitInfos proto.InternalMessageInfo

func (m *CommitInfos) GetCommitInfo() []*CommitInfo {
	if m != nil {
		return m.CommitInfo
	}
	return nil
}

type CreateBranchRequest struct {
	Head *Commit `protobuf:"bytes,1,opt,name=head,proto3" json:"head,omitempty"`
	// s_branch matches the field number and type of SetBranchRequest.Branch in
	// Pachyderm 1.6--so that operations (generated by pachyderm 1.6's
	// Admin.Export) can be deserialized by pachyderm 1.7 correctly
	SBranch              string    `protobuf:"bytes,2,opt,name=s_branch,json=sBranch,proto3" json:"s_branch,omitempty"`
	Branch               *Branch   `protobuf:"bytes,3,opt,name=branch,proto3" json:"branch,omitempty"`
	Provenance           []*Branch `protobuf:"bytes,4,rep,name=provenance,proto3" json:"provenance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CreateBranchRequest) Reset()         { *m = CreateBranchRequest{} }
func (m *CreateBranchRequest) String() string { return proto.CompactTextString(m) }
func (*CreateBranchRequest) ProtoMessage()    {}
func (*CreateBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{33}
}
func (m *CreateBranchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateBranchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateBranchRequest.Merge(m, src)
}
func (m *CreateBranchRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateBranchRequest proto.InternalMessageInfo

func (m *CreateBranchRequest) GetHead() *Commit {
	if m != nil {
		return m.Head
	}
	return nil
}

func (m *CreateBranchRequest) GetSBranch() string {
	if m != nil {
		return m.SBranch
	}
	return ""
}

func (m *CreateBranchRequest) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *CreateBranchRequest) GetProvenance() []*Branch {
	if m != nil {
		return m.Provenance
	}
	return nil
}

type InspectBranchRequest struct {
	Branch               *Branch  `protobuf:"bytes,1,opt,name=branch,proto3" json:"branch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectBranchRequest) Reset()         { *m = InspectBranchRequest{} }
func (m *InspectBranchRequest) String() string { return proto.CompactTextString(m) }
func (*InspectBranchRequest) ProtoMessage()    {}
func (*InspectBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{34}
}
func (m *InspectBranchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectBranchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectBranchRequest.Merge(m, src)
}
func (m *InspectBranchRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectBranchRequest proto.InternalMessageInfo

func (m *InspectBranchRequest) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

type ListBranchRequest struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Reverse              bool     `protobuf:"varint,2,opt,name=reverse,proto3" json:"reverse,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListBranchRequest) Reset()         { *m = ListBranchRequest{} }
func (m *ListBranchRequest) String() string { return proto.CompactTextString(m) }
func (*ListBranchRequest) ProtoMessage()    {}
func (*ListBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{35}
}
func (m *ListBranchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListBranchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListBranchRequest.Merge(m, src)
}
func (m *ListBranchRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListBranchRequest proto.InternalMessageInfo

func (m *ListBranchRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *ListBranchRequest) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

type DeleteBranchRequest struct {
	Branch               *Branch  `protobuf:"bytes,1,opt,name=branch,proto3" json:"branch,omitempty"`
	Force                bool     `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteBranchRequest) Reset()         { *m = DeleteBranchRequest{} }
func (m *DeleteBranchRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteBranchRequest) ProtoMessage()    {}
func (*DeleteBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{36}
}
func (m *DeleteBranchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteBranchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteBranchRequest.Merge(m, src)
}
func (m *DeleteBranchRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteBranchRequest proto.InternalMessageInfo

func (m *DeleteBranchRequest) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *DeleteBranchRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

type DeleteCommitRequest struct {
	Commit               *Commit  `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteCommitRequest) Reset()         { *m = DeleteCommitRequest{} }
func (m *DeleteCommitRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteCommitRequest) ProtoMessage()    {}
func (*DeleteCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{37}
}
func (m *DeleteCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteCommitRequest.Merge(m, src)
}
func (m *DeleteCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteCommitRequest proto.InternalMessageInfo

func (m *DeleteCommitRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

type FlushCommitRequest struct {
	Commits              []*Commit `protobuf:"bytes,1,rep,name=commits,proto3" json:"commits,omitempty"`
	ToRepos              []*Repo   `protobuf:"bytes,2,rep,name=to_repos,json=toRepos,proto3" json:"to_repos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *FlushCommitRequest) Reset()         { *m = FlushCommitRequest{} }
func (m *FlushCommitRequest) String() string { return proto.CompactTextString(m) }
func (*FlushCommitRequest) ProtoMessage()    {}
func (*FlushCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{38}
}
func (m *FlushCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlushCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlushCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlushCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlushCommitRequest.Merge(m, src)
}
func (m *FlushCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *FlushCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FlushCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FlushCommitRequest proto.InternalMessageInfo

func (m *FlushCommitRequest) GetCommits() []*Commit {
	if m != nil {
		return m.Commits
	}
	return nil
}

func (m *FlushCommitRequest) GetToRepos() []*Repo {
	if m != nil {
		return m.ToRepos
	}
	return nil
}

type SubscribeCommitRequest struct {
	Repo   *Repo             `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Branch string            `protobuf:"bytes,2,opt,name=branch,proto3" json:"branch,omitempty"`
	Prov   *CommitProvenance `protobuf:"bytes,5,opt,name=prov,proto3" json:"prov,omitempty"`
	// only commits created since this commit are returned
	From *Commit `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// Don't return commits until they're in (at least) the desired state.
	State                CommitState `protobuf:"varint,4,opt,name=state,proto3,enum=pfs.CommitState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SubscribeCommitRequest) Reset()         { *m = SubscribeCommitRequest{} }
func (m *SubscribeCommitRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeCommitRequest) ProtoMessage()    {}
func (*SubscribeCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{39}
}
func (m *SubscribeCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeCommitRequest.Merge(m, src)
}
func (m *SubscribeCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeCommitRequest proto.InternalMessageInfo

func (m *SubscribeCommitRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *SubscribeCommitRequest) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *SubscribeCommitRequest) GetProv() *CommitProvenance {
	if m != nil {
		return m.Prov
	}
	return nil
}

func (m *SubscribeCommitRequest) GetFrom() *Commit {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *SubscribeCommitRequest) GetState() CommitState {
	if m != nil {
		return m.State
	}
	return CommitState_STARTED
}

type GetFileRequest struct {
	File                 *File    `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	OffsetBytes          int64    `protobuf:"varint,2,opt,name=offset_bytes,json=offsetBytes,proto3" json:"offset_bytes,omitempty"`
	SizeBytes            int64    `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetFileRequest) Reset()         { *m = GetFileRequest{} }
func (m *GetFileRequest) String() string { return proto.CompactTextString(m) }
func (*GetFileRequest) ProtoMessage()    {}
func (*GetFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{40}
}
func (m *GetFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFileRequest.Merge(m, src)
}
func (m *GetFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetFileRequest proto.InternalMessageInfo

func (m *GetFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *GetFileRequest) GetOffsetBytes() int64 {
	if m != nil {
		return m.OffsetBytes
	}
	return 0
}

func (m *GetFileRequest) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

// An OverwriteIndex specifies the index of objects from which new writes
// are applied to.  Existing objects starting from the index are deleted.
// We want a separate message for ObjectIndex because we want to be able to
// distinguish between a zero index and a non-existent index.
type OverwriteIndex struct {
	Index                int64    `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OverwriteIndex) Reset()         { *m = OverwriteIndex{} }
func (m *OverwriteIndex) String() string { return proto.CompactTextString(m) }
func (*OverwriteIndex) ProtoMessage()    {}
func (*OverwriteIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{41}
}
func (m *OverwriteIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OverwriteIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OverwriteIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OverwriteIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OverwriteIndex.Merge(m, src)
}
func (m *OverwriteIndex) XXX_Size() int {
	return m.Size()
}
func (m *OverwriteIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_OverwriteIndex.DiscardUnknown(m)
}

var xxx_messageInfo_OverwriteIndex proto.InternalMessageInfo

func (m *OverwriteIndex) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

type PutFileRequest struct {
	File  *File  `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	Value []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Url   string `protobuf:"bytes,5,opt,name=url,proto3" json:"url,omitempty"`
	// applies only to URLs that can be recursively walked, for example s3:// URLs
	Recursive bool `protobuf:"varint,6,opt,name=recursive,proto3" json:"recursive,omitempty"`
	// Delimiter causes data to be broken up into separate files with File.Path
	// as a prefix.
	Delimiter Delimiter `protobuf:"varint,7,opt,name=delimiter,proto3,enum=pfs.Delimiter" json:"delimiter,omitempty"`
	// TargetFileDatums specifies the target number of datums in each written
	// file it may be lower if data does not split evenly, but will never be
	// higher, unless the value is 0.
	TargetFileDatums int64 `protobuf:"varint,8,opt,name=target_file_datums,json=targetFileDatums,proto3" json:"target_file_datums,omitempty"`
	// TargetFileBytes specifies the target number of bytes in each written
	// file, files may have more or fewer bytes than the target.
	TargetFileBytes int64 `protobuf:"varint,9,opt,name=target_file_bytes,json=targetFileBytes,proto3" json:"target_file_bytes,omitempty"`
	// header_records is an option for splitting data when 'delimiter' is not NONE
	// (or SQL). It specifies the number of records that are converted to a
	// header and applied to all file shards.
	//
	// This is particularly useful for CSV files, where the first row often
	// contains column titles; if 'header_records' is set to one in that case,
	// the first row will be associated with the directory that contains the rest
	// of the split-up csv rows as files, and if any data is retrieved from that
	// directory by GetFile, it will appear to begin with that first row of
	// column labels (including in pipeline workers).
	//
	// Note that SQL files have their own logic for determining headers (their
	// header is not a number of records, but a collection of SQL commands that
	// create the relevant tables and such). This way, SQL files retrieved by
	// GetFile can be passed to psql, and they will set up the appropriate tables
	// before inserting the records in the files that were retrieved.
	HeaderRecords int64 `protobuf:"varint,11,opt,name=header_records,json=headerRecords,proto3" json:"header_records,omitempty"`
	// overwrite_index is the object index where the write starts from.  All
	// existing objects starting from the index are deleted.
	OverwriteIndex       *OverwriteIndex `protobuf:"bytes,10,opt,name=overwrite_index,json=overwriteIndex,proto3" json:"overwrite_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PutFileRequest) Reset()         { *m = PutFileRequest{} }
func (m *PutFileRequest) String() string { return proto.CompactTextString(m) }
func (*PutFileRequest) ProtoMessage()    {}
func (*PutFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{42}
}
func (m *PutFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutFileRequest.Merge(m, src)
}
func (m *PutFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *PutFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PutFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PutFileRequest proto.InternalMessageInfo

func (m *PutFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *PutFileRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *PutFileRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *PutFileRequest) GetRecursive() bool {
	if m != nil {
		return m.Recursive
	}
	return false
}

func (m *PutFileRequest) GetDelimiter() Delimiter {
	if m != nil {
		return m.Delimiter
	}
	return Delimiter_NONE
}

func (m *PutFileRequest) GetTargetFileDatums() int64 {
	if m != nil {
		return m.TargetFileDatums
	}
	return 0
}

func (m *PutFileRequest) GetTargetFileBytes() int64 {
	if m != nil {
		return m.TargetFileBytes
	}
	return 0
}

func (m *PutFileRequest) GetHeaderRecords() int64 {
	if m != nil {
		return m.HeaderRecords
	}
	return 0
}

func (m *PutFileRequest) GetOverwriteIndex() *OverwriteIndex {
	if m != nil {
		return m.OverwriteIndex
	}
	return nil
}

// PutFileRecord is used to record PutFile requests in etcd temporarily.
type PutFileRecord struct {
	SizeBytes            int64           `protobuf:"varint,1,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	ObjectHash           string          `protobuf:"bytes,2,opt,name=object_hash,json=objectHash,proto3" json:"object_hash,omitempty"`
	OverwriteIndex       *OverwriteIndex `protobuf:"bytes,3,opt,name=overwrite_index,json=overwriteIndex,proto3" json:"overwrite_index,omitempty"`
	BlockRef             *BlockRef       `protobuf:"bytes,4,opt,name=block_ref,json=blockRef,proto3" json:"block_ref,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PutFileRecord) Reset()         { *m = PutFileRecord{} }
func (m *PutFileRecord) String() string { return proto.CompactTextString(m) }
func (*PutFileRecord) ProtoMessage()    {}
func (*PutFileRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{43}
}
func (m *PutFileRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutFileRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutFileRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutFileRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutFileRecord.Merge(m, src)
}
func (m *PutFileRecord) XXX_Size() int {
	return m.Size()
}
func (m *PutFileRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_PutFileRecord.DiscardUnknown(m)
}

var xxx_messageInfo_PutFileRecord proto.InternalMessageInfo

func (m *PutFileRecord) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *PutFileRecord) GetObjectHash() string {
	if m != nil {
		return m.ObjectHash
	}
	return ""
}

func (m *PutFileRecord) GetOverwriteIndex() *OverwriteIndex {
	if m != nil {
		return m.OverwriteIndex
	}
	return nil
}

func (m *PutFileRecord) GetBlockRef() *BlockRef {
	if m != nil {
		return m.BlockRef
	}
	return nil
}

type PutFileRecords struct {
	Split                bool             `protobuf:"varint,1,opt,name=split,proto3" json:"split,omitempty"`
	Records              []*PutFileRecord `protobuf:"bytes,2,rep,name=records,proto3" json:"records,omitempty"`
	Tombstone            bool             `protobuf:"varint,3,opt,name=tombstone,proto3" json:"tombstone,omitempty"`
	Header               *PutFileRecord   `protobuf:"bytes,4,opt,name=header,proto3" json:"header,omitempty"`
	Footer               *PutFileRecord   `protobuf:"bytes,5,opt,name=footer,proto3" json:"footer,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *PutFileRecords) Reset()         { *m = PutFileRecords{} }
func (m *PutFileRecords) String() string { return proto.CompactTextString(m) }
func (*PutFileRecords) ProtoMessage()    {}
func (*PutFileRecords) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{44}
}
func (m *PutFileRecords) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutFileRecords) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutFileRecords.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutFileRecords) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutFileRecords.Merge(m, src)
}
func (m *PutFileRecords) XXX_Size() int {
	return m.Size()
}
func (m *PutFileRecords) XXX_DiscardUnknown() {
	xxx_messageInfo_PutFileRecords.DiscardUnknown(m)
}

var xxx_messageInfo_PutFileRecords proto.InternalMessageInfo

func (m *PutFileRecords) GetSplit() bool {
	if m != nil {
		return m.Split
	}
	return false
}

func (m *PutFileRecords) GetRecords() []*PutFileRecord {
	if m != nil {
		return m.Records
	}
	return nil
}

func (m *PutFileRecords) GetTombstone() bool {
	if m != nil {
		return m.Tombstone
	}
	return false
}

func (m *PutFileRecords) GetHeader() *PutFileRecord {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *PutFileRecords) GetFooter() *PutFileRecord {
	if m != nil {
		return m.Footer
	}
	return nil
}

type CopyFileRequest struct {
	Src                  *File    `protobuf:"bytes,1,opt,name=src,proto3" json:"src,omitempty"`
	Dst                  *File    `protobuf:"bytes,2,opt,name=dst,proto3" json:"dst,omitempty"`
	Overwrite            bool     `protobuf:"varint,3,opt,name=overwrite,proto3" json:"overwrite,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CopyFileRequest) Reset()         { *m = CopyFileRequest{} }
func (m *CopyFileRequest) String() string { return proto.CompactTextString(m) }
func (*CopyFileRequest) ProtoMessage()    {}
func (*CopyFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{45}
}
func (m *CopyFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CopyFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CopyFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CopyFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CopyFileRequest.Merge(m, src)
}
func (m *CopyFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *CopyFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CopyFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CopyFileRequest proto.InternalMessageInfo

func (m *CopyFileRequest) GetSrc() *File {
	if m != nil {
		return m.Src
	}
	return nil
}

func (m *CopyFileRequest) GetDst() *File {
	if m != nil {
		return m.Dst
	}
	return nil
}

func (m *CopyFileRequest) GetOverwrite() bool {
	if m != nil {
		return m.Overwrite
	}
	return false
}

type InspectFileRequest struct {
	File                 *File    `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectFileRequest) Reset()         { *m = InspectFileRequest{} }
func (m *InspectFileRequest) String() string { return proto.CompactTextString(m) }
func (*InspectFileRequest) ProtoMessage()    {}
func (*InspectFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{46}
}
func (m *InspectFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectFileRequest.Merge(m, src)
}
func (m *InspectFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectFileRequest proto.InternalMessageInfo

func (m *InspectFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

type ListFileRequest struct {
	// File is the parent directory of the files we want to list. This sets the
	// repo, the commit/branch, and path prefix of files we're interested in
	// If the "path" field is omitted, a list of files at the top level of the repo
	// is returned
	File *File `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	// Full indicates whether the result should include file contents, which may
	// be large (i.e. the list of children for directories, and the list of object
	// references for regular files)
	Full bool `protobuf:"varint,2,opt,name=full,proto3" json:"full,omitempty"`
	// History indicates how many historical versions you want returned. Its
	// semantics are:
	// 0: Return the files as they are at the commit in `file`. FileInfo.File
	//    will equal File in this request.
	// 1: Return the files as they are in the last commit they were modified in.
	//    (This will have the same hash as if you'd passed 0, but
	//    FileInfo.File.Commit will be different.
	// 2: Return the above and the files as they are in the next-last commit they
	//    were modified in.
	// 3: etc.
	//-1: Return all historical versions.
	History              int64    `protobuf:"varint,3,opt,name=history,proto3" json:"history,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListFileRequest) Reset()         { *m = ListFileRequest{} }
func (m *ListFileRequest) String() string { return proto.CompactTextString(m) }
func (*ListFileRequest) ProtoMessage()    {}
func (*ListFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{47}
}
func (m *ListFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListFileRequest.Merge(m, src)
}
func (m *ListFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListFileRequest proto.InternalMessageInfo

func (m *ListFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *ListFileRequest) GetFull() bool {
	if m != nil {
		return m.Full
	}
	return false
}

func (m *ListFileRequest) GetHistory() int64 {
	if m != nil {
		return m.History
	}
	return 0
}

type WalkFileRequest struct {
	File                 *File    `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WalkFileRequest) Reset()         { *m = WalkFileRequest{} }
func (m *WalkFileRequest) String() string { return proto.CompactTextString(m) }
func (*WalkFileRequest) ProtoMessage()    {}
func (*WalkFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{48}
}
func (m *WalkFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalkFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalkFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalkFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalkFileRequest.Merge(m, src)
}
func (m *WalkFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *WalkFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WalkFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WalkFileRequest proto.InternalMessageInfo

func (m *WalkFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

type GlobFileRequest struct {
	Commit               *Commit  `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	Pattern              string   `protobuf:"bytes,2,opt,name=pattern,proto3" json:"pattern,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GlobFileRequest) Reset()         { *m = GlobFileRequest{} }
func (m *GlobFileRequest) String() string { return proto.CompactTextString(m) }
func (*GlobFileRequest) ProtoMessage()    {}
func (*GlobFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{49}
}
func (m *GlobFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobFileRequest.Merge(m, src)
}
func (m *GlobFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *GlobFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GlobFileRequest proto.InternalMessageInfo

func (m *GlobFileRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *GlobFileRequest) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

// FileInfos is the result of both ListFile and GlobFile
type FileInfos struct {
	FileInfo             []*FileInfo `protobuf:"bytes,1,rep,name=file_info,json=fileInfo,proto3" json:"file_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *FileInfos) Reset()         { *m = FileInfos{} }
func (m *FileInfos) String() string { return proto.CompactTextString(m) }
func (*FileInfos) ProtoMessage()    {}
func (*FileInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{50}
}
func (m *FileInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileInfos.Merge(m, src)
}
func (m *FileInfos) XXX_Size() int {
	return m.Size()
}
func (m *FileInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_FileInfos.DiscardUnknown(m)
}

var xxx_messageInfo_FileInfos proto.InternalMessageInfo

func (m *FileInfos) GetFileInfo() []*FileInfo {
	if m != nil {
		return m.FileInfo
	}
	return nil
}

type DiffFileRequest struct {
	NewFile *File `protobuf:"bytes,1,opt,name=new_file,json=newFile,proto3" json:"new_file,omitempty"`
	// OldFile may be left nil in which case the same path in the parent of
	// NewFile's commit will be used.
	OldFile              *File    `protobuf:"bytes,2,opt,name=old_file,json=oldFile,proto3" json:"old_file,omitempty"`
	Shallow              bool     `protobuf:"varint,3,opt,name=shallow,proto3" json:"shallow,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiffFileRequest) Reset()         { *m = DiffFileRequest{} }
func (m *DiffFileRequest) String() string { return proto.CompactTextString(m) }
func (*DiffFileRequest) ProtoMessage()    {}
func (*DiffFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{51}
}
func (m *DiffFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiffFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiffFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiffFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiffFileRequest.Merge(m, src)
}
func (m *DiffFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *DiffFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DiffFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DiffFileRequest proto.InternalMessageInfo

func (m *DiffFileRequest) GetNewFile() *File {
	if m != nil {
		return m.NewFile
	}
	return nil
}

func (m *DiffFileRequest) GetOldFile() *File {
	if m != nil {
		return m.OldFile
	}
	return nil
}

func (m *DiffFileRequest) GetShallow() bool {
	if m != nil {
		return m.Shallow
	}
	return false
}

type DiffFileResponse struct {
	NewFiles             []*FileInfo `protobuf:"bytes,1,rep,name=new_files,json=newFiles,proto3" json:"new_files,omitempty"`
	OldFiles             []*FileInfo `protobuf:"bytes,2,rep,name=old_files,json=oldFiles,proto3" json:"old_files,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DiffFileResponse) Reset()         { *m = DiffFileResponse{} }
func (m *DiffFileResponse) String() string { return proto.CompactTextString(m) }
func (*DiffFileResponse) ProtoMessage()    {}
func (*DiffFileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{52}
}
func (m *DiffFileResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiffFileResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiffFileResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiffFileResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiffFileResponse.Merge(m, src)
}
func (m *DiffFileResponse) XXX_Size() int {
	return m.Size()
}
func (m *DiffFileResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DiffFileResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DiffFileResponse proto.InternalMessageInfo

func (m *DiffFileResponse) GetNewFiles() []*FileInfo {
	if m != nil {
		return m.NewFiles
	}
	return nil
}

func (m *DiffFileResponse) GetOldFiles() []*FileInfo {
	if m != nil {
		return m.OldFiles
	}
	return nil
}

type DeleteFileRequest struct {
	File                 *File    `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteFileRequest) Reset()         { *m = DeleteFileRequest{} }
func (m *DeleteFileRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteFileRequest) ProtoMessage()    {}
func (*DeleteFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{53}
}
func (m *DeleteFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteFileRequest.Merge(m, src)
}
func (m *DeleteFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteFileRequest proto.InternalMessageInfo

func (m *DeleteFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

type FsckRequest struct {
	Fix                  bool     `protobuf:"varint,1,opt,name=fix,proto3" json:"fix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FsckRequest) Reset()         { *m = FsckRequest{} }
func (m *FsckRequest) String() string { return proto.CompactTextString(m) }
func (*FsckRequest) ProtoMessage()    {}
func (*FsckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{54}
}
func (m *FsckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FsckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FsckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FsckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsckRequest.Merge(m, src)
}
func (m *FsckRequest) XXX_Size() int {
	return m.Size()
}
func (m *FsckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FsckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FsckRequest proto.InternalMessageInfo

func (m *FsckRequest) GetFix() bool {
	if m != nil {
		return m.Fix
	}
	return false
}

type FsckResponse struct {
	Fix                  string   `protobuf:"bytes,1,opt,name=fix,proto3" json:"fix,omitempty"`
	Error                string   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FsckResponse) Reset()         { *m = FsckResponse{} }
func (m *FsckResponse) String() string { return proto.CompactTextString(m) }
func (*FsckResponse) ProtoMessage()    {}
func (*FsckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{55}
}
func (m *FsckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FsckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FsckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FsckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsckResponse.Merge(m, src)
}
func (m *FsckResponse) XXX_Size() int {
	return m.Size()
}
func (m *FsckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FsckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FsckResponse proto.InternalMessageInfo

func (m *FsckResponse) GetFix() string {
	if m != nil {
		return m.Fix
	}
	return ""
}

func (m *FsckResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type FileInfoNewStorage struct {
	File                 *File    `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	Hash                 string   `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileInfoNewStorage) Reset()         { *m = FileInfoNewStorage{} }
func (m *FileInfoNewStorage) String() string { return proto.CompactTextString(m) }
func (*FileInfoNewStorage) ProtoMessage()    {}
func (*FileInfoNewStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{56}
}
func (m *FileInfoNewStorage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileInfoNewStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileInfoNewStorage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileInfoNewStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileInfoNewStorage.Merge(m, src)
}
func (m *FileInfoNewStorage) XXX_Size() int {
	return m.Size()
}
func (m *FileInfoNewStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_FileInfoNewStorage.DiscardUnknown(m)
}

var xxx_messageInfo_FileInfoNewStorage proto.InternalMessageInfo

func (m *FileInfoNewStorage) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *FileInfoNewStorage) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type PutTarRequest struct {
	Commit               *Commit  `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutTarRequest) Reset()         { *m = PutTarRequest{} }
func (m *PutTarRequest) String() string { return proto.CompactTextString(m) }
func (*PutTarRequest) ProtoMessage()    {}
func (*PutTarRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{57}
}
func (m *PutTarRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutTarRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutTarRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutTarRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutTarRequest.Merge(m, src)
}
func (m *PutTarRequest) XXX_Size() int {
	return m.Size()
}
func (m *PutTarRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PutTarRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PutTarRequest proto.InternalMessageInfo

func (m *PutTarRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *PutTarRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type GetTarRequest struct {
	File                 *File    `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTarRequest) Reset()         { *m = GetTarRequest{} }
func (m *GetTarRequest) String() string { return proto.CompactTextString(m) }
func (*GetTarRequest) ProtoMessage()    {}
func (*GetTarRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{58}
}
func (m *GetTarRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTarRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTarRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTarRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTarRequest.Merge(m, src)
}
func (m *GetTarRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTarRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTarRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTarRequest proto.InternalMessageInfo

func (m *GetTarRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

type GetTarConditionalRequest struct {
	File                 *File    `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	Skip                 bool     `protobuf:"varint,2,opt,name=skip,proto3" json:"skip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTarConditionalRequest) Reset()         { *m = GetTarConditionalRequest{} }
func (m *GetTarConditionalRequest) String() string { return proto.CompactTextString(m) }
func (*GetTarConditionalRequest) ProtoMessage()    {}
func (*GetTarConditionalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{59}
}
func (m *GetTarConditionalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTarConditionalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTarConditionalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTarConditionalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTarConditionalRequest.Merge(m, src)
}
func (m *GetTarConditionalRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTarConditionalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTarConditionalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTarConditionalRequest proto.InternalMessageInfo

func (m *GetTarConditionalRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *GetTarConditionalRequest) GetSkip() bool {
	if m != nil {
		return m.Skip
	}
	return false
}

type GetTarConditionalResponse struct {
	FileInfo             *FileInfoNewStorage `protobuf:"bytes,1,opt,name=file_info,json=fileInfo,proto3" json:"file_info,omitempty"`
	Data                 []byte              `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Eof                  bool                `protobuf:"varint,3,opt,name=eof,proto3" json:"eof,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GetTarConditionalResponse) Reset()         { *m = GetTarConditionalResponse{} }
func (m *GetTarConditionalResponse) String() string { return proto.CompactTextString(m) }
func (*GetTarConditionalResponse) ProtoMessage()    {}
func (*GetTarConditionalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{60}
}
func (m *GetTarConditionalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTarConditionalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTarConditionalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTarConditionalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTarConditionalResponse.Merge(m, src)
}
func (m *GetTarConditionalResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTarConditionalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTarConditionalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTarConditionalResponse proto.InternalMessageInfo

func (m *GetTarConditionalResponse) GetFileInfo() *FileInfoNewStorage {
	if m != nil {
		return m.FileInfo
	}
	return nil
}

func (m *GetTarConditionalResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *GetTarConditionalResponse) GetEof() bool {
	if m != nil {
		return m.Eof
	}
	return false
}

type PutObjectRequest struct {
	Value                []byte   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Tags                 []*Tag   `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
	Block                *Block   `protobuf:"bytes,3,opt,name=block,proto3" json:"block,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutObjectRequest) Reset()         { *m = PutObjectRequest{} }
func (m *PutObjectRequest) String() string { return proto.CompactTextString(m) }
func (*PutObjectRequest) ProtoMessage()    {}
func (*PutObjectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{61}
}
func (m *PutObjectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutObjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutObjectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutObjectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutObjectRequest.Merge(m, src)
}
func (m *PutObjectRequest) XXX_Size() int {
	return m.Size()
}
func (m *PutObjectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PutObjectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PutObjectRequest proto.InternalMessageInfo

func (m *PutObjectRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *PutObjectRequest) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *PutObjectRequest) GetBlock() *Block {
	if m != nil {
		return m.Block
	}
	return nil
}

type CreateObjectRequest struct {
	Object               *Object   `protobuf:"bytes,1,opt,name=object,proto3" json:"object,omitempty"`
	BlockRef             *BlockRef `protobuf:"bytes,2,opt,name=block_ref,json=blockRef,proto3" json:"block_ref,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CreateObjectRequest) Reset()         { *m = CreateObjectRequest{} }
func (m *CreateObjectRequest) String() string { return proto.CompactTextString(m) }
func (*CreateObjectRequest) ProtoMessage()    {}
func (*CreateObjectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{62}
}
func (m *CreateObjectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateObjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateObjectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateObjectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateObjectRequest.Merge(m, src)
}
func (m *CreateObjectRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateObjectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateObjectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateObjectRequest proto.InternalMessageInfo

func (m *CreateObjectRequest) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *CreateObjectRequest) GetBlockRef() *BlockRef {
	if m != nil {
		return m.BlockRef
	}
	return nil
}

type GetObjectsRequest struct {
	Objects     []*Object `protobuf:"bytes,1,rep,name=objects,proto3" json:"objects,omitempty"`
	OffsetBytes uint64    `protobuf:"varint,2,opt,name=offset_bytes,json=offsetBytes,proto3" json:"offset_bytes,omitempty"`
	// The number of bytes requested.
	SizeBytes uint64 `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// The total amount of bytes in these objects.  It's OK if it's not
	// entirely accurate or if it's unknown (in which case it'd be set to 0).
	// It's used primarily as a hint for cache eviction.
	TotalSize            uint64   `protobuf:"varint,4,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetObjectsRequest) Reset()         { *m = GetObjectsRequest{} }
func (m *GetObjectsRequest) String() string { return proto.CompactTextString(m) }
func (*GetObjectsRequest) ProtoMessage()    {}
func (*GetObjectsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{63}
}
func (m *GetObjectsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetObjectsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetObjectsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetObjectsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetObjectsRequest.Merge(m, src)
}
func (m *GetObjectsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetObjectsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetObjectsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetObjectsRequest proto.InternalMessageInfo

func (m *GetObjectsRequest) GetObjects() []*Object {
	if m != nil {
		return m.Objects
	}
	return nil
}

func (m *GetObjectsRequest) GetOffsetBytes() uint64 {
	if m != nil {
		return m.OffsetBytes
	}
	return 0
}

func (m *GetObjectsRequest) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *GetObjectsRequest) GetTotalSize() uint64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

type PutBlockRequest struct {
	Block                *Block   `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
	Value                []byte   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutBlockRequest) Reset()         { *m = PutBlockRequest{} }
func (m *PutBlockRequest) String() string { return proto.CompactTextString(m) }
func (*PutBlockRequest) ProtoMessage()    {}
func (*PutBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{64}
}
func (m *PutBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutBlockRequest.Merge(m, src)
}
func (m *PutBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *PutBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PutBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PutBlockRequest proto.InternalMessageInfo

func (m *PutBlockRequest) GetBlock() *Block {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *PutBlockRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type GetBlockRequest struct {
	Block                *Block   `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBlockRequest) Reset()         { *m = GetBlockRequest{} }
func (m *GetBlockRequest) String() string { return proto.CompactTextString(m) }
func (*GetBlockRequest) ProtoMessage()    {}
func (*GetBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{65}
}
func (m *GetBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlockRequest.Merge(m, src)
}
func (m *GetBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlockRequest proto.InternalMessageInfo

func (m *GetBlockRequest) GetBlock() *Block {
	if m != nil {
		return m.Block
	}
	return nil
}

type GetBlocksRequest struct {
	BlockRefs   []*BlockRef `protobuf:"bytes,1,rep,name=blockRefs,proto3" json:"blockRefs,omitempty"`
	OffsetBytes uint64      `protobuf:"varint,2,opt,name=offset_bytes,json=offsetBytes,proto3" json:"offset_bytes,omitempty"`
	// The number of bytes requested.
	SizeBytes uint64 `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// The total amount of bytes in these blocks.  It's OK if it's not
	// entirely accurate or if it's unknown (in which case it'd be set to 0).
	// It's used primarily as a hint for cache eviction.
	TotalSize            uint64   `protobuf:"varint,4,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBlocksRequest) Reset()         { *m = GetBlocksRequest{} }
func (m *GetBlocksRequest) String() string { return proto.CompactTextString(m) }
func (*GetBlocksRequest) ProtoMessage()    {}
func (*GetBlocksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{66}
}
func (m *GetBlocksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlocksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlocksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlocksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlocksRequest.Merge(m, src)
}
func (m *GetBlocksRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetBlocksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlocksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlocksRequest proto.InternalMessageInfo

func (m *GetBlocksRequest) GetBlockRefs() []*BlockRef {
	if m != nil {
		return m.BlockRefs
	}
	return nil
}

func (m *GetBlocksRequest) GetOffsetBytes() uint64 {
	if m != nil {
		return m.OffsetBytes
	}
	return 0
}

func (m *GetBlocksRequest) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *GetBlocksRequest) GetTotalSize() uint64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

type ListBlockRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListBlockRequest) Reset()         { *m = ListBlockRequest{} }
func (m *ListBlockRequest) String() string { return proto.CompactTextString(m) }
func (*ListBlockRequest) ProtoMessage()    {}
func (*ListBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{67}
}
func (m *ListBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListBlockRequest.Merge(m, src)
}
func (m *ListBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListBlockRequest proto.InternalMessageInfo

type TagObjectRequest struct {
	Object               *Object  `protobuf:"bytes,1,opt,name=object,proto3" json:"object,omitempty"`
	Tags                 []*Tag   `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TagObjectRequest) Reset()         { *m = TagObjectRequest{} }
func (m *TagObjectRequest) String() string { return proto.CompactTextString(m) }
func (*TagObjectRequest) ProtoMessage()    {}
func (*TagObjectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{68}
}
func (m *TagObjectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagObjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagObjectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagObjectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagObjectRequest.Merge(m, src)
}
func (m *TagObjectRequest) XXX_Size() int {
	return m.Size()
}
func (m *TagObjectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TagObjectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TagObjectRequest proto.InternalMessageInfo

func (m *TagObjectRequest) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *TagObjectRequest) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

type ListObjectsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListObjectsRequest) Reset()         { *m = ListObjectsRequest{} }
func (m *ListObjectsRequest) String() string { return proto.CompactTextString(m) }
func (*ListObjectsRequest) ProtoMessage()    {}
func (*ListObjectsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{69}
}
func (m *ListObjectsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListObjectsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListObjectsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListObjectsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListObjectsRequest.Merge(m, src)
}
func (m *ListObjectsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListObjectsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListObjectsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListObjectsRequest proto.InternalMessageInfo

type ListTagsRequest struct {
	Prefix               string   `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	IncludeObject        bool     `protobuf:"varint,2,opt,name=include_object,json=includeObject,proto3" json:"include_object,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListTagsRequest) Reset()         { *m = ListTagsRequest{} }
func (m *ListTagsRequest) String() string { return proto.CompactTextString(m) }
func (*ListTagsRequest) ProtoMessage()    {}
func (*ListTagsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{70}
}
func (m *ListTagsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTagsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTagsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListTagsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTagsRequest.Merge(m, src)
}
func (m *ListTagsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListTagsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTagsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListTagsRequest proto.InternalMessageInfo

func (m *ListTagsRequest) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *ListTagsRequest) GetIncludeObject() bool {
	if m != nil {
		return m.IncludeObject
	}
	return false
}

type ListTagsResponse struct {
	Tag                  *Tag     `protobuf:"bytes,1,opt,name=tag,proto3" json:"tag,omitempty"`
	Object               *Object  `protobuf:"bytes,2,opt,name=object,proto3" json:"object,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListTagsResponse) Reset()         { *m = ListTagsResponse{} }
func (m *ListTagsResponse) String() string { return proto.CompactTextString(m) }
func (*ListTagsResponse) ProtoMessage()    {}
func (*ListTagsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{71}
}
func (m *ListTagsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTagsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTagsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListTagsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTagsResponse.Merge(m, src)
}
func (m *ListTagsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListTagsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTagsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListTagsResponse proto.InternalMessageInfo

func (m *ListTagsResponse) GetTag() *Tag {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *ListTagsResponse) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

type DeleteObjectsRequest struct {
	Objects              []*Object `protobuf:"bytes,1,rep,name=objects,proto3" json:"objects,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *DeleteObjectsRequest) Reset()         { *m = DeleteObjectsRequest{} }
func (m *DeleteObjectsRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteObjectsRequest) ProtoMessage()    {}
func (*DeleteObjectsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{72}
}
func (m *DeleteObjectsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteObjectsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteObjectsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteObjectsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteObjectsRequest.Merge(m, src)
}
func (m *DeleteObjectsRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteObjectsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteObjectsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteObjectsRequest proto.InternalMessageInfo

func (m *DeleteObjectsRequest) GetObjects() []*Object {
	if m != nil {
		return m.Objects
	}
	return nil
}

type DeleteObjectsResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteObjectsResponse) Reset()         { *m = DeleteObjectsResponse{} }
func (m *DeleteObjectsResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteObjectsResponse) ProtoMessage()    {}
func (*DeleteObjectsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{73}
}
func (m *DeleteObjectsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteObjectsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteObjectsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteObjectsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteObjectsResponse.Merge(m, src)
}
func (m *DeleteObjectsResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteObjectsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteObjectsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteObjectsResponse proto.InternalMessageInfo

type DeleteTagsRequest struct {
	Tags                 []*Tag   `protobuf:"bytes,1,rep,name=tags,proto3" json:"tags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteTagsRequest) Reset()         { *m = DeleteTagsRequest{} }
func (m *DeleteTagsRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteTagsRequest) ProtoMessage()    {}
func (*DeleteTagsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{74}
}
func (m *DeleteTagsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteTagsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteTagsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteTagsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteTagsRequest.Merge(m, src)
}
func (m *DeleteTagsRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteTagsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteTagsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteTagsRequest proto.InternalMessageInfo

func (m *DeleteTagsRequest) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

type DeleteTagsResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteTagsResponse) Reset()         { *m = DeleteTagsResponse{} }
func (m *DeleteTagsResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteTagsResponse) ProtoMessage()    {}
func (*DeleteTagsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{75}
}
func (m *DeleteTagsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteTagsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteTagsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteTagsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteTagsResponse.Merge(m, src)
}
func (m *DeleteTagsResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteTagsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteTagsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteTagsResponse proto.InternalMessageInfo

type CheckObjectRequest struct {
	Object               *Object  `protobuf:"bytes,1,opt,name=object,proto3" json:"object,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckObjectRequest) Reset()         { *m = CheckObjectRequest{} }
func (m *CheckObjectRequest) String() string { return proto.CompactTextString(m) }
func (*CheckObjectRequest) ProtoMessage()    {}
func (*CheckObjectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{76}
}
func (m *CheckObjectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckObjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckObjectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckObjectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckObjectRequest.Merge(m, src)
}
func (m *CheckObjectRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckObjectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckObjectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckObjectRequest proto.InternalMessageInfo

func (m *CheckObjectRequest) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

type CheckObjectResponse struct {
	Exists               bool     `protobuf:"varint,1,opt,name=exists,proto3" json:"exists,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckObjectResponse) Reset()         { *m = CheckObjectResponse{} }
func (m *CheckObjectResponse) String() string { return proto.CompactTextString(m) }
func (*CheckObjectResponse) ProtoMessage()    {}
func (*CheckObjectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{77}
}
func (m *CheckObjectResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckObjectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckObjectResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckObjectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckObjectResponse.Merge(m, src)
}
func (m *CheckObjectResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckObjectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckObjectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckObjectResponse proto.InternalMessageInfo

func (m *CheckObjectResponse) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

type Objects struct {
	Objects              []*Object `protobuf:"bytes,1,rep,name=objects,proto3" json:"objects,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Objects) Reset()         { *m = Objects{} }
func (m *Objects) String() string { return proto.CompactTextString(m) }
func (*Objects) ProtoMessage()    {}
func (*Objects) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{78}
}
func (m *Objects) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Objects) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Objects.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Objects) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Objects.Merge(m, src)
}
func (m *Objects) XXX_Size() int {
	return m.Size()
}
func (m *Objects) XXX_DiscardUnknown() {
	xxx_messageInfo_Objects.DiscardUnknown(m)
}

var xxx_messageInfo_Objects proto.InternalMessageInfo

func (m *Objects) GetObjects() []*Object {
	if m != nil {
		return m.Objects
	}
	return nil
}

type PutObjDirectRequest struct {
	Obj                  string   `protobuf:"bytes,1,opt,name=obj,proto3" json:"obj,omitempty"`
	Value                []byte   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutObjDirectRequest) Reset()         { *m = PutObjDirectRequest{} }
func (m *PutObjDirectRequest) String() string { return proto.CompactTextString(m) }
func (*PutObjDirectRequest) ProtoMessage()    {}
func (*PutObjDirectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{79}
}
func (m *PutObjDirectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutObjDirectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutObjDirectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutObjDirectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutObjDirectRequest.Merge(m, src)
}
func (m *PutObjDirectRequest) XXX_Size() int {
	return m.Size()
}
func (m *PutObjDirectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PutObjDirectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PutObjDirectRequest proto.InternalMessageInfo

func (m *PutObjDirectRequest) GetObj() string {
	if m != nil {
		return m.Obj
	}
	return ""
}

func (m *PutObjDirectRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type GetObjDirectRequest struct {
	Obj                  string   `protobuf:"bytes,1,opt,name=obj,proto3" json:"obj,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetObjDirectRequest) Reset()         { *m = GetObjDirectRequest{} }
func (m *GetObjDirectRequest) String() string { return proto.CompactTextString(m) }
func (*GetObjDirectRequest) ProtoMessage()    {}
func (*GetObjDirectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{80}
}
func (m *GetObjDirectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetObjDirectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetObjDirectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetObjDirectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetObjDirectRequest.Merge(m, src)
}
func (m *GetObjDirectRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetObjDirectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetObjDirectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetObjDirectRequest proto.InternalMessageInfo

func (m *GetObjDirectRequest) GetObj() string {
	if m != nil {
		return m.Obj
	}
	return ""
}

type ObjectIndex struct {
	Objects              map[string]*BlockRef `protobuf:"bytes,1,rep,name=objects,proto3" json:"objects,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Tags                 map[string]*Object   `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ObjectIndex) Reset()         { *m = ObjectIndex{} }
func (m *ObjectIndex) String() string { return proto.CompactTextString(m) }
func (*ObjectIndex) ProtoMessage()    {}
func (*ObjectIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_b48f014707f6595c, []int{81}
}
func (m *ObjectIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectIndex.Merge(m, src)
}
func (m *ObjectIndex) XXX_Size() int {
	return m.Size()
}
func (m *ObjectIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectIndex.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectIndex proto.InternalMessageInfo

func (m *ObjectIndex) GetObjects() map[string]*BlockRef {
	if m != nil {
		return m.Objects
	}
	return nil
}

func (m *ObjectIndex) GetTags() map[string]*Object {
	if m != nil {
		return m.Tags
	}
	return nil
}

func init() {
	proto.RegisterEnum("pfs.OriginKind", OriginKind_name, OriginKind_value)
	proto.RegisterEnum("pfs.FileType", FileType_name, FileType_value)
	proto.RegisterEnum("pfs.CommitState", CommitState_name, CommitState_value)
	proto.RegisterEnum("pfs.Delimiter", Delimiter_name, Delimiter_value)
	proto.RegisterType((*Repo)(nil), "pfs.Repo")
	proto.RegisterType((*Branch)(nil), "pfs.Branch")
	proto.RegisterType((*BranchInfo)(nil), "pfs.BranchInfo")
	proto.RegisterType((*BranchInfos)(nil), "pfs.BranchInfos")
	proto.RegisterType((*File)(nil), "pfs.File")
	proto.RegisterType((*Block)(nil), "pfs.Block")
	proto.RegisterType((*Object)(nil), "pfs.Object")
	proto.RegisterType((*Tag)(nil), "pfs.Tag")
	proto.RegisterType((*RepoInfo)(nil), "pfs.RepoInfo")
	proto.RegisterType((*RepoAuthInfo)(nil), "pfs.RepoAuthInfo")
	proto.RegisterType((*CommitOrigin)(nil), "pfs.CommitOrigin")
	proto.RegisterType((*Commit)(nil), "pfs.Commit")
	proto.RegisterType((*CommitRange)(nil), "pfs.CommitRange")
	proto.RegisterType((*CommitProvenance)(nil), "pfs.CommitProvenance")
	proto.RegisterType((*CommitInfo)(nil), "pfs.CommitInfo")
	proto.RegisterType((*FileInfo)(nil), "pfs.FileInfo")
	proto.RegisterType((*ByteRange)(nil), "pfs.ByteRange")
	proto.RegisterType((*BlockRef)(nil), "pfs.BlockRef")
	proto.RegisterType((*ObjectInfo)(nil), "pfs.ObjectInfo")
	proto.RegisterType((*Compaction)(nil), "pfs.Compaction")
	proto.RegisterType((*Shard)(nil), "pfs.Shard")
	proto.RegisterType((*PathRange)(nil), "pfs.PathRange")
	proto.RegisterType((*CreateRepoRequest)(nil), "pfs.CreateRepoRequest")
	proto.RegisterType((*InspectRepoRequest)(nil), "pfs.InspectRepoRequest")
	proto.RegisterType((*ListRepoRequest)(nil), "pfs.ListRepoRequest")
	proto.RegisterType((*ListRepoResponse)(nil), "pfs.ListRepoResponse")
	proto.RegisterType((*DeleteRepoRequest)(nil), "pfs.DeleteRepoRequest")
	proto.RegisterType((*StartCommitRequest)(nil), "pfs.StartCommitRequest")
	proto.RegisterType((*BuildCommitRequest)(nil), "pfs.BuildCommitRequest")
	proto.RegisterType((*FinishCommitRequest)(nil), "pfs.FinishCommitRequest")
	proto.RegisterType((*InspectCommitRequest)(nil), "pfs.InspectCommitRequest")
	proto.RegisterType((*ListCommitRequest)(nil), "pfs.ListCommitRequest")
	proto.RegisterType((*CommitInfos)(nil), "pfs.CommitInfos")
	proto.RegisterType((*CreateBranchRequest)(nil), "pfs.CreateBranchRequest")
	proto.RegisterType((*InspectBranchRequest)(nil), "pfs.InspectBranchRequest")
	proto.RegisterType((*ListBranchRequest)(nil), "pfs.ListBranchRequest")
	proto.RegisterType((*DeleteBranchRequest)(nil), "pfs.DeleteBranchRequest")
	proto.RegisterType((*DeleteCommitRequest)(nil), "pfs.DeleteCommitRequest")
	proto.RegisterType((*FlushCommitRequest)(nil), "pfs.FlushCommitRequest")
	proto.RegisterType((*SubscribeCommitRequest)(nil), "pfs.SubscribeCommitRequest")
	proto.RegisterType((*GetFileRequest)(nil), "pfs.GetFileRequest")
	proto.RegisterType((*OverwriteIndex)(nil), "pfs.OverwriteIndex")
	proto.RegisterType((*PutFileRequest)(nil), "pfs.PutFileRequest")
	proto.RegisterType((*PutFileRecord)(nil), "pfs.PutFileRecord")
	proto.RegisterType((*PutFileRecords)(nil), "pfs.PutFileRecords")
	proto.RegisterType((*CopyFileRequest)(nil), "pfs.CopyFileRequest")
	proto.RegisterType((*InspectFileRequest)(nil), "pfs.InspectFileRequest")
	proto.RegisterType((*ListFileRequest)(nil), "pfs.ListFileRequest")
	proto.RegisterType((*WalkFileRequest)(nil), "pfs.WalkFileRequest")
	proto.RegisterType((*GlobFileRequest)(nil), "pfs.GlobFileRequest")
	proto.RegisterType((*FileInfos)(nil), "pfs.FileInfos")
	proto.RegisterType((*DiffFileRequest)(nil), "pfs.DiffFileRequest")
	proto.RegisterType((*DiffFileResponse)(nil), "pfs.DiffFileResponse")
	proto.RegisterType((*DeleteFileRequest)(nil), "pfs.DeleteFileRequest")
	proto.RegisterType((*FsckRequest)(nil), "pfs.FsckRequest")
	proto.RegisterType((*FsckResponse)(nil), "pfs.FsckResponse")
	proto.RegisterType((*FileInfoNewStorage)(nil), "pfs.FileInfoNewStorage")
	proto.RegisterType((*PutTarRequest)(nil), "pfs.PutTarRequest")
	proto.RegisterType((*GetTarRequest)(nil), "pfs.GetTarRequest")
	proto.RegisterType((*GetTarConditionalRequest)(nil), "pfs.GetTarConditionalRequest")
	proto.RegisterType((*GetTarConditionalResponse)(nil), "pfs.GetTarConditionalResponse")
	proto.RegisterType((*PutObjectRequest)(nil), "pfs.PutObjectRequest")
	proto.RegisterType((*CreateObjectRequest)(nil), "pfs.CreateObjectRequest")
	proto.RegisterType((*GetObjectsRequest)(nil), "pfs.GetObjectsRequest")
	proto.RegisterType((*PutBlockRequest)(nil), "pfs.PutBlockRequest")
	proto.RegisterType((*GetBlockRequest)(nil), "pfs.GetBlockRequest")
	proto.RegisterType((*GetBlocksRequest)(nil), "pfs.GetBlocksRequest")
	proto.RegisterType((*ListBlockRequest)(nil), "pfs.ListBlockRequest")
	proto.RegisterType((*TagObjectRequest)(nil), "pfs.TagObjectRequest")
	proto.RegisterType((*ListObjectsRequest)(nil), "pfs.ListObjectsRequest")
	proto.RegisterType((*ListTagsRequest)(nil), "pfs.ListTagsRequest")
	proto.RegisterType((*ListTagsResponse)(nil), "pfs.ListTagsResponse")
	proto.RegisterType((*DeleteObjectsRequest)(nil), "pfs.DeleteObjectsRequest")
	proto.RegisterType((*DeleteObjectsResponse)(nil), "pfs.DeleteObjectsResponse")
	proto.RegisterType((*DeleteTagsRequest)(nil), "pfs.DeleteTagsRequest")
	proto.RegisterType((*DeleteTagsResponse)(nil), "pfs.DeleteTagsResponse")
	proto.RegisterType((*CheckObjectRequest)(nil), "pfs.CheckObjectRequest")
	proto.RegisterType((*CheckObjectResponse)(nil), "pfs.CheckObjectResponse")
	proto.RegisterType((*Objects)(nil), "pfs.Objects")
	proto.RegisterType((*PutObjDirectRequest)(nil), "pfs.PutObjDirectRequest")
	proto.RegisterType((*GetObjDirectRequest)(nil), "pfs.GetObjDirectRequest")
	proto.RegisterType((*ObjectIndex)(nil), "pfs.ObjectIndex")
	proto.RegisterMapType((map[string]*BlockRef)(nil), "pfs.ObjectIndex.ObjectsEntry")
	proto.RegisterMapType((map[string]*Object)(nil), "pfs.ObjectIndex.TagsEntry")
}

func init() { proto.RegisterFile("client/pfs/pfs.proto", fileDescriptor_b48f014707f6595c) }

var fileDescriptor_b48f014707f6595c = []byte{
	// 3715 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x3b, 0xcb, 0x72, 0xdb, 0x56,
	0x96, 0x02, 0x09, 0x92, 0xe0, 0x21, 0x25, 0x41, 0x57, 0xb2, 0x4c, 0xd3, 0xf1, 0x23, 0xb0, 0x9d,
	0x38, 0x4a, 0x22, 0x29, 0x52, 0x1e, 0x7e, 0xc4, 0x71, 0x59, 0x2f, 0x5b, 0x8e, 0xc7, 0xd6, 0x80,
	0x4a, 0x66, 0x26, 0x35, 0x33, 0x2c, 0x90, 0xbc, 0x24, 0x61, 0x43, 0x04, 0x03, 0x80, 0x96, 0x95,
	0xcd, 0x2c, 0xe7, 0x07, 0x66, 0x37, 0x9b, 0xa9, 0xe9, 0x1f, 0x48, 0xf5, 0xae, 0xd7, 0xbd, 0xe9,
	0xea, 0xaa, 0xae, 0xea, 0x2f, 0xe8, 0xea, 0xf2, 0x07, 0xf4, 0x07, 0x64, 0xd3, 0x5d, 0xf7, 0x05,
	0x5c, 0x3c, 0xf8, 0x90, 0xab, 0x7b, 0x91, 0x10, 0xb8, 0xe7, 0x71, 0xcf, 0x3d, 0xe7, 0xdc, 0xf3,
	0x82, 0x0c, 0x2b, 0x6d, 0xc7, 0xc6, 0x83, 0x60, 0x63, 0xd8, 0xf5, 0xc9, 0x7f, 0xeb, 0x43, 0xcf,
	0x0d, 0x5c, 0x94, 0x1f, 0x76, 0xfd, 0xfa, 0xe5, 0x9e, 0xeb, 0xf6, 0x1c, 0xbc, 0x41, 0x97, 0x5a,
	0xa3, 0xee, 0x06, 0x3e, 0x19, 0x06, 0x67, 0x0c, 0xa3, 0x7e, 0x2d, 0x09, 0x0c, 0xec, 0x13, 0xec,
	0x07, 0xd6, 0xc9, 0x90, 0x23, 0x5c, 0x4d, 0x22, 0x9c, 0x7a, 0xd6, 0x70, 0x88, 0x3d, 0xbe, 0x45,
	0x7d, 0xa5, 0xe7, 0xf6, 0x5c, 0xfa, 0xb8, 0x41, 0x9e, 0xf8, 0xea, 0x2a, 0x17, 0xc7, 0x1a, 0x05,
	0x7d, 0xfa, 0x3f, 0xb6, 0x6e, 0xd4, 0x41, 0x35, 0xf1, 0xd0, 0x45, 0x08, 0xd4, 0x81, 0x75, 0x82,
	0x6b, 0xca, 0x75, 0xe5, 0x76, 0xd9, 0xa4, 0xcf, 0xc6, 0x7d, 0x28, 0xee, 0x78, 0xd6, 0xa0, 0xdd,
	0x47, 0x57, 0x40, 0xf5, 0xf0, 0xd0, 0xa5, 0xd0, 0xca, 0x56, 0x79, 0x9d, 0x1c, 0x88, 0x90, 0x99,
	0x74, 0x39, 0x24, 0xce, 0x49, 0xc4, 0xbf, 0x28, 0x00, 0x8c, 0xfa, 0x70, 0xd0, 0x75, 0xd1, 0x0d,
	0x28, 0xb6, 0xe8, 0x5b, 0x4d, 0xa5, 0x3c, 0x2a, 0x94, 0x07, 0x43, 0x30, 0x39, 0x08, 0x5d, 0x03,
	0xb5, 0x8f, 0xad, 0x0e, 0xe5, 0x23, 0x50, 0x76, 0xdd, 0x93, 0x13, 0x3b, 0x30, 0x29, 0x00, 0x7d,
	0x0c, 0x30, 0xf4, 0xdc, 0xd7, 0x78, 0x60, 0x0d, 0xda, 0xb8, 0x96, 0xbf, 0x9e, 0x4f, 0x72, 0x92,
	0xc0, 0x04, 0xd9, 0x1f, 0xb5, 0x04, 0x72, 0x21, 0x03, 0x39, 0x02, 0xa3, 0x3b, 0xb0, 0xd4, 0xb1,
	0x3d, 0xdc, 0x0e, 0x9a, 0xd2, 0x06, 0xc5, 0x34, 0x8d, 0xce, 0xb0, 0x8e, 0xa2, 0x6d, 0xb2, 0x34,
	0xf7, 0x10, 0x2a, 0xd1, 0xd9, 0x7d, 0xb4, 0x09, 0x15, 0x76, 0xc2, 0xa6, 0x3d, 0xe8, 0x12, 0x2d,
	0x12, 0xb6, 0x8b, 0x12, 0x5b, 0x82, 0x66, 0x42, 0x2b, 0x7c, 0x36, 0x1e, 0x82, 0x7a, 0x60, 0x3b,
	0x98, 0xa8, 0xad, 0x4d, 0x15, 0xc0, 0x55, 0x1f, 0xd3, 0x09, 0x07, 0x11, 0x09, 0x86, 0x56, 0xd0,
	0x17, 0xea, 0x27, 0xcf, 0xc6, 0x65, 0x28, 0xec, 0x38, 0x6e, 0xfb, 0x15, 0x01, 0xf6, 0x2d, 0xbf,
	0x2f, 0xc4, 0x23, 0xcf, 0xc6, 0x7b, 0x50, 0x7c, 0xd1, 0x7a, 0x89, 0xdb, 0x41, 0x26, 0xf4, 0x12,
	0xe4, 0x8f, 0xad, 0x5e, 0xe6, 0xb9, 0xfe, 0xaa, 0x80, 0x46, 0xec, 0x4e, 0x4d, 0x3a, 0xc5, 0x29,
	0x3e, 0x87, 0x52, 0xdb, 0xc3, 0x56, 0x80, 0x85, 0x3d, 0xeb, 0xeb, 0xcc, 0x73, 0xd7, 0x85, 0xe7,
	0xae, 0x1f, 0x0b, 0xd7, 0x36, 0x05, 0x2a, 0xba, 0x02, 0xe0, 0xdb, 0x3f, 0xe1, 0x66, 0xeb, 0x2c,
	0xc0, 0x7e, 0x2d, 0x7f, 0x5d, 0xb9, 0xad, 0x9a, 0x65, 0xb2, 0xb2, 0x43, 0x16, 0xd0, 0x75, 0xa8,
	0x74, 0xb0, 0xdf, 0xf6, 0xec, 0x61, 0x60, 0xbb, 0x83, 0x5a, 0x81, 0xca, 0x26, 0x2f, 0xa1, 0x0f,
	0x41, 0x63, 0x7a, 0xc4, 0x7e, 0xad, 0x94, 0xb6, 0x5f, 0x08, 0x44, 0xeb, 0x50, 0x26, 0xf7, 0x80,
	0x99, 0xa4, 0x48, 0x25, 0x5c, 0x0a, 0xcf, 0xf0, 0x68, 0x14, 0x30, 0xa3, 0x68, 0x16, 0x7f, 0x7a,
	0xaa, 0x6a, 0xaa, 0x5e, 0x30, 0xbe, 0x81, 0xaa, 0x0c, 0x47, 0xeb, 0x50, 0xb5, 0xda, 0x6d, 0xec,
	0xfb, 0x4d, 0x07, 0xbf, 0xc6, 0x0e, 0x55, 0xc6, 0xc2, 0x56, 0x65, 0x9d, 0x5e, 0xb1, 0x46, 0xdb,
	0x1d, 0x62, 0xb3, 0xc2, 0x10, 0x9e, 0x11, 0xb8, 0xb1, 0x0d, 0x55, 0x66, 0xbd, 0x17, 0x9e, 0xdd,
	0xb3, 0x07, 0xe8, 0x06, 0xa8, 0xaf, 0xec, 0x41, 0x87, 0xd3, 0x31, 0x9f, 0x60, 0xa0, 0x6f, 0xed,
	0x41, 0xc7, 0xa4, 0x40, 0xe3, 0x21, 0x14, 0x19, 0xd1, 0x34, 0x9d, 0xaf, 0x42, 0xce, 0x66, 0xea,
	0x2e, 0xef, 0x14, 0xdf, 0xfe, 0xe9, 0x5a, 0xee, 0x70, 0xcf, 0xcc, 0xd9, 0x1d, 0xa3, 0x01, 0x15,
	0xee, 0x33, 0xd6, 0xa0, 0x87, 0xd1, 0xfb, 0x50, 0x70, 0xdc, 0x53, 0xec, 0x65, 0x39, 0x15, 0x83,
	0x10, 0x94, 0x11, 0x89, 0x2a, 0x59, 0x77, 0x91, 0x41, 0x8c, 0x7f, 0x07, 0x9d, 0x2d, 0x48, 0x97,
	0x61, 0x26, 0x7f, 0x8d, 0x62, 0x41, 0x6e, 0x6c, 0x2c, 0x30, 0xfe, 0x50, 0x04, 0x60, 0x74, 0x22,
	0x7e, 0x9c, 0x87, 0xf1, 0xe2, 0xf8, 0x20, 0xf3, 0x11, 0x14, 0x5d, 0xaa, 0xe0, 0xda, 0x92, 0x64,
	0x74, 0xd9, 0x28, 0x26, 0x47, 0x48, 0x7a, 0x9b, 0x96, 0xf6, 0xb6, 0x4d, 0x98, 0x1f, 0x5a, 0x1e,
	0x1e, 0x04, 0x4d, 0x2e, 0x5d, 0x86, 0xba, 0xaa, 0x0c, 0x83, 0x5b, 0x70, 0x13, 0xe6, 0xdb, 0x7d,
	0xdb, 0xe9, 0x70, 0x02, 0xbf, 0x56, 0x91, 0x9c, 0x54, 0x50, 0x50, 0x0c, 0xf6, 0xe2, 0x93, 0x8b,
	0xe4, 0x07, 0x96, 0x47, 0x2e, 0x52, 0x7e, 0xfa, 0x45, 0xe2, 0xa8, 0xe8, 0x4b, 0xd0, 0xba, 0xf6,
	0xc0, 0xf6, 0xfb, 0xb8, 0xc3, 0x43, 0xee, 0x24, 0xb2, 0x10, 0x37, 0x71, 0x01, 0x0b, 0xc9, 0x0b,
	0xf8, 0x45, 0x2c, 0x02, 0xeb, 0x54, 0xf6, 0x0b, 0x92, 0xec, 0x91, 0x2f, 0xc4, 0x62, 0xf1, 0x47,
	0xa0, 0x7b, 0xd8, 0xea, 0x9c, 0xc9, 0xd1, 0xb5, 0x7a, 0x5d, 0xb9, 0x9d, 0x37, 0x17, 0xe9, 0xba,
	0xe4, 0x42, 0x9b, 0xb1, 0xb0, 0x5d, 0xa6, 0x3b, 0xe8, 0xb2, 0x76, 0x88, 0x0b, 0xc7, 0x62, 0xf7,
	0x35, 0x50, 0x03, 0x0f, 0xe3, 0x5a, 0x49, 0xd2, 0x3d, 0x8b, 0x6f, 0x26, 0x05, 0x10, 0x67, 0x26,
	0xbf, 0x7e, 0x6d, 0x5e, 0xd2, 0x35, 0xc7, 0x60, 0x10, 0xe2, 0x3a, 0x1d, 0x2b, 0x18, 0x9d, 0xf8,
	0xb5, 0x85, 0x34, 0x17, 0x0e, 0x42, 0xf7, 0xe0, 0x92, 0xd8, 0x56, 0x18, 0xdc, 0x6f, 0xfa, 0x23,
	0x7a, 0xbd, 0x6b, 0x88, 0x1e, 0xe7, 0x62, 0x88, 0xc0, 0xcd, 0xd7, 0x60, 0xe0, 0x6c, 0xda, 0xae,
	0x65, 0x3b, 0x23, 0x0f, 0xd7, 0x96, 0xb3, 0x69, 0x0f, 0x18, 0x18, 0x7d, 0x09, 0x17, 0xd3, 0xb4,
	0x81, 0x1b, 0x58, 0x4e, 0x6d, 0x85, 0x52, 0x5e, 0x48, 0x52, 0x1e, 0x13, 0xe0, 0x53, 0x55, 0x2b,
	0xea, 0xa5, 0xa7, 0xaa, 0x06, 0x7a, 0xc5, 0xf8, 0x75, 0x0e, 0x34, 0x92, 0x52, 0x44, 0xe8, 0xee,
	0xda, 0x0e, 0x8e, 0x85, 0x11, 0x02, 0x34, 0xe9, 0x32, 0x5a, 0x83, 0x32, 0xf9, 0x6d, 0x06, 0x67,
	0x43, 0x96, 0xd4, 0x17, 0xb6, 0xe6, 0x43, 0x9c, 0xe3, 0xb3, 0x21, 0x26, 0xfe, 0xc2, 0x9e, 0xa6,
	0x05, 0xec, 0x3b, 0x50, 0x66, 0x02, 0x13, 0xf7, 0x85, 0xa9, 0x7e, 0x18, 0x21, 0xa3, 0x3a, 0x68,
	0xf4, 0x1a, 0x78, 0x78, 0x40, 0x13, 0x71, 0xd9, 0x0c, 0xdf, 0xd1, 0x2d, 0x28, 0xb9, 0xd4, 0x34,
	0x7e, 0x4d, 0x4b, 0x9b, 0x54, 0xc0, 0xd0, 0xc7, 0x50, 0x6e, 0x91, 0x24, 0x68, 0xe2, 0xae, 0xcf,
	0x3d, 0x89, 0x9d, 0x63, 0x87, 0xaf, 0x9a, 0x11, 0x3c, 0x4c, 0x85, 0xc4, 0x8b, 0xaa, 0x3c, 0x15,
	0x7e, 0x05, 0x65, 0x72, 0x0c, 0x16, 0x35, 0x57, 0xe4, 0xa8, 0xa9, 0x8a, 0x40, 0xb9, 0x22, 0x07,
	0x4a, 0x55, 0xc4, 0x46, 0x13, 0x34, 0xb1, 0x07, 0xba, 0x0e, 0x05, 0xba, 0x0b, 0xd7, 0x36, 0x48,
	0x12, 0x30, 0x00, 0xba, 0x09, 0x05, 0x8f, 0x6c, 0xc1, 0xa3, 0xc7, 0x02, 0xc3, 0x10, 0x1b, 0x9b,
	0x0c, 0x68, 0xfc, 0x07, 0x00, 0x3b, 0xa0, 0x08, 0x88, 0xec, 0x98, 0xb1, 0x80, 0x28, 0x1c, 0x96,
	0x81, 0x88, 0x21, 0xe9, 0x0e, 0x4d, 0x0f, 0x77, 0x39, 0xf3, 0x84, 0x02, 0x34, 0xa1, 0x00, 0x63,
	0x9b, 0xc6, 0xdb, 0xa1, 0xd5, 0xa6, 0x81, 0xed, 0x16, 0x2c, 0xd8, 0x83, 0xe1, 0x88, 0x94, 0x43,
	0xb8, 0x6b, 0xbf, 0xc1, 0x7e, 0x2d, 0x47, 0x6d, 0x30, 0x4f, 0x57, 0x8f, 0xf8, 0xa2, 0xf1, 0x5f,
	0x50, 0x68, 0xf4, 0x2d, 0xaf, 0x83, 0x36, 0x00, 0xda, 0x21, 0x35, 0x17, 0x69, 0x51, 0xdc, 0x5a,
	0xbe, 0x6c, 0x4a, 0x28, 0xd9, 0x67, 0x3e, 0xb2, 0x82, 0xbe, 0x7c, 0x66, 0x74, 0x0d, 0x2a, 0xee,
	0x28, 0xa0, 0x72, 0x90, 0x0a, 0x27, 0x4f, 0x23, 0x30, 0xb0, 0x25, 0x82, 0x4c, 0x2c, 0x14, 0x12,
	0xc5, 0x2d, 0x54, 0xce, 0xb4, 0x50, 0x59, 0x58, 0xc8, 0x83, 0xa5, 0x5d, 0x5a, 0x73, 0xd0, 0xf4,
	0x89, 0x7f, 0x1c, 0x61, 0x7f, 0x6a, 0x7a, 0x4d, 0xe4, 0x83, 0x7c, 0x3a, 0x1f, 0xac, 0x42, 0x71,
	0x34, 0xec, 0x58, 0x01, 0xa6, 0x31, 0x57, 0x33, 0xf9, 0xdb, 0x53, 0x55, 0xcb, 0xe9, 0x79, 0x63,
	0x1b, 0xd0, 0xe1, 0xc0, 0x1f, 0x12, 0x0b, 0xcd, 0xbc, 0xa9, 0x71, 0x11, 0x16, 0x9f, 0xd9, 0xbe,
	0x4c, 0xf1, 0x54, 0xd5, 0x14, 0x3d, 0x67, 0x7c, 0x03, 0x7a, 0x04, 0xf0, 0x87, 0xee, 0xc0, 0xa7,
	0x37, 0x97, 0x10, 0xc9, 0x75, 0xe6, 0x7c, 0xc8, 0x90, 0x15, 0x34, 0x1e, 0x7f, 0x32, 0x7e, 0x80,
	0xa5, 0x3d, 0xec, 0xe0, 0x73, 0x69, 0x60, 0x05, 0x0a, 0x5d, 0xd7, 0x6b, 0x33, 0xab, 0x69, 0x26,
	0x7b, 0x41, 0x3a, 0xe4, 0x2d, 0xc7, 0xa1, 0xfa, 0xd0, 0x4c, 0xf2, 0x68, 0xfc, 0xac, 0x00, 0x6a,
	0x90, 0x4c, 0xc4, 0x63, 0x36, 0xe7, 0x7e, 0x03, 0x8a, 0x2c, 0x19, 0x66, 0x66, 0x71, 0x06, 0x4a,
	0x6a, 0x59, 0xcd, 0xd4, 0x32, 0xcf, 0xf3, 0xcc, 0x04, 0x22, 0xb5, 0xc7, 0x93, 0x53, 0x61, 0xc6,
	0xe4, 0xc4, 0x8d, 0xf3, 0x3f, 0x79, 0x40, 0x3b, 0xa3, 0x30, 0xef, 0x9e, 0x4b, 0xe4, 0xd5, 0x58,
	0x77, 0x33, 0x4e, 0xa0, 0xe2, 0xac, 0xd9, 0x52, 0x24, 0xb4, 0xfc, 0xd4, 0x84, 0x56, 0x9a, 0x21,
	0xa1, 0x69, 0xe3, 0x13, 0xda, 0x02, 0xe4, 0x0e, 0xf7, 0x78, 0x15, 0x9d, 0x3b, 0xdc, 0x4b, 0x04,
	0xf3, 0x72, 0x32, 0x98, 0x4b, 0x95, 0x08, 0xbc, 0x5b, 0x25, 0x52, 0x99, 0xbd, 0x12, 0xe1, 0x66,
	0xf9, 0x45, 0x81, 0xe5, 0x03, 0xba, 0x94, 0xb2, 0xcb, 0xf4, 0x82, 0x30, 0xe1, 0x4a, 0xb9, 0xb4,
	0x2b, 0xcd, 0xae, 0xea, 0xc2, 0x0c, 0xaa, 0x2e, 0x8d, 0x57, 0x75, 0x5c, 0xb5, 0xc5, 0xa4, 0x6a,
	0x57, 0xa0, 0x40, 0xa7, 0x00, 0x3c, 0x6e, 0xb0, 0x17, 0x63, 0x00, 0x2b, 0x3c, 0x60, 0xbc, 0xc3,
	0xe1, 0x3f, 0x83, 0x0a, 0x0b, 0xfe, 0x7e, 0x40, 0x02, 0x12, 0xcb, 0xe3, 0x72, 0x25, 0xd5, 0x20,
	0xeb, 0x26, 0x50, 0x24, 0xfa, 0x6c, 0xfc, 0xbf, 0x02, 0x4b, 0x24, 0xa6, 0xc4, 0x77, 0x9b, 0x12,
	0x13, 0xae, 0x81, 0xda, 0xf5, 0xdc, 0x93, 0xcc, 0xae, 0x9d, 0x00, 0xd0, 0x65, 0xc8, 0x05, 0x6e,
	0x4c, 0xc3, 0x1c, 0x9c, 0x0b, 0x48, 0xcb, 0x52, 0x1c, 0x8c, 0x4e, 0x5a, 0xd8, 0xa3, 0x27, 0x57,
	0x4d, 0xfe, 0x86, 0x6a, 0x50, 0xf2, 0xf0, 0x6b, 0xec, 0xf9, 0x98, 0xfa, 0xa7, 0x66, 0x8a, 0x57,
	0xd2, 0x5c, 0x47, 0x8d, 0x01, 0x6d, 0xae, 0xd9, 0x81, 0xd3, 0xcd, 0x75, 0x84, 0x46, 0x53, 0x0f,
	0x7f, 0x36, 0x7e, 0xa5, 0xc0, 0x32, 0x8b, 0xfd, 0xbc, 0x35, 0xe0, 0xe7, 0x14, 0xe3, 0x07, 0x65,
	0xdc, 0xf8, 0xe1, 0x12, 0x68, 0x7e, 0x53, 0x6a, 0x5d, 0xca, 0x66, 0xc9, 0xe7, 0x13, 0x92, 0x1b,
	0xb1, 0x90, 0x34, 0xa6, 0xf5, 0x88, 0x8f, 0x2f, 0xd4, 0x89, 0xe3, 0x0b, 0xe3, 0x7e, 0x68, 0xfb,
	0xb8, 0x94, 0xd1, 0x4e, 0xca, 0xf8, 0xee, 0xe9, 0x19, 0xb3, 0x63, 0x9c, 0x72, 0x8a, 0x1d, 0x25,
	0x8d, 0xe7, 0xe2, 0x1a, 0x3f, 0x82, 0x65, 0x96, 0x29, 0xce, 0x2f, 0x49, 0x76, 0xc6, 0x30, 0xee,
	0x09, 0x8e, 0xe7, 0xf7, 0x6b, 0xc3, 0x02, 0x74, 0xe0, 0x8c, 0x92, 0xf1, 0xe0, 0x16, 0x94, 0x44,
	0x47, 0xa5, 0xa4, 0x3b, 0x2a, 0x01, 0x43, 0x37, 0x41, 0x0b, 0xdc, 0x26, 0x39, 0x2f, 0xab, 0x68,
	0x62, 0x7a, 0x28, 0x05, 0x2e, 0xf9, 0xf5, 0x8d, 0xdf, 0x2a, 0xb0, 0xda, 0x18, 0xb5, 0x48, 0x98,
	0x68, 0xe1, 0x73, 0x5d, 0x86, 0xd5, 0x58, 0x6f, 0x5b, 0x96, 0xba, 0x4e, 0x95, 0xd8, 0x96, 0xfa,
	0xf2, 0xd8, 0x1c, 0x40, 0x51, 0xc2, 0xfb, 0x94, 0x1f, 0x77, 0x9f, 0x3e, 0x80, 0x02, 0xbb, 0xd2,
	0xea, 0x98, 0x2b, 0xcd, 0xc0, 0xc6, 0x8f, 0xb0, 0xf0, 0x18, 0x07, 0xb4, 0xae, 0x8f, 0x84, 0x9f,
	0x54, 0xf7, 0xbf, 0x0f, 0x55, 0xb7, 0xdb, 0xf5, 0x71, 0xc0, 0xa3, 0x54, 0x8e, 0x36, 0x17, 0x15,
	0xb6, 0xc6, 0xe2, 0x54, 0xba, 0xdc, 0xcf, 0x4b, 0x61, 0xcc, 0xf8, 0x00, 0x16, 0x5e, 0xbc, 0xc6,
	0xde, 0xa9, 0x67, 0x07, 0xf8, 0x70, 0xd0, 0xc1, 0x6f, 0x88, 0xfd, 0x6d, 0xf2, 0x40, 0xf7, 0xcc,
	0x9b, 0xec, 0xc5, 0xf8, 0x4b, 0x0e, 0x16, 0x8e, 0x46, 0xe7, 0x91, 0x6d, 0x05, 0x0a, 0xaf, 0x2d,
	0x67, 0xc4, 0x22, 0x75, 0xd5, 0x64, 0x2f, 0xa4, 0xf2, 0x18, 0x79, 0x0e, 0xcf, 0x60, 0xe4, 0x11,
	0xbd, 0x47, 0x2a, 0xa0, 0xf6, 0xc8, 0xf3, 0xed, 0xd7, 0x98, 0x86, 0x59, 0xcd, 0x8c, 0x16, 0xd0,
	0x27, 0x50, 0xee, 0x60, 0xc7, 0x3e, 0xb1, 0x03, 0xec, 0xd1, 0x68, 0xbd, 0xc0, 0x2b, 0xcf, 0x3d,
	0xb1, 0x6a, 0x46, 0x08, 0xe8, 0x13, 0x40, 0x81, 0xe5, 0xf5, 0x70, 0xd0, 0xa4, 0xed, 0x90, 0x94,
	0x4f, 0xf3, 0xa6, 0xce, 0x20, 0x44, 0xc2, 0x3d, 0x16, 0xe1, 0xd7, 0x60, 0x49, 0xc6, 0x8e, 0x72,
	0x68, 0xde, 0x5c, 0x8c, 0x90, 0x99, 0x1a, 0x6f, 0xc1, 0x02, 0x89, 0x28, 0xd8, 0x6b, 0x7a, 0xb8,
	0xed, 0x7a, 0x1d, 0x9f, 0x66, 0xc6, 0xbc, 0x39, 0xcf, 0x56, 0x4d, 0xb6, 0x88, 0xbe, 0x86, 0x45,
	0x57, 0xa8, 0xb3, 0xc9, 0xd4, 0xc8, 0x12, 0xef, 0x32, 0x4b, 0x31, 0x31, 0x55, 0x9b, 0x0b, 0x6e,
	0xec, 0x9d, 0x25, 0x50, 0x3e, 0xb7, 0xfa, 0x8d, 0x02, 0xf3, 0xa1, 0xc2, 0x09, 0xf3, 0x84, 0x25,
	0x95, 0x84, 0x25, 0x69, 0xe5, 0x4d, 0x33, 0x58, 0x93, 0x76, 0x45, 0x39, 0x5e, 0x79, 0xd3, 0xa5,
	0x27, 0x96, 0xdf, 0xcf, 0x92, 0x2d, 0x3f, 0xb3, 0x6c, 0xf1, 0xce, 0x44, 0x9d, 0xdc, 0x99, 0xfc,
	0x5e, 0x91, 0x9c, 0x85, 0x29, 0x66, 0x05, 0x0a, 0xfe, 0xd0, 0xe1, 0x71, 0x42, 0x33, 0xd9, 0x0b,
	0xfa, 0x84, 0x44, 0x30, 0xa6, 0x4e, 0x76, 0xb7, 0x11, 0xeb, 0x2a, 0x64, 0x5a, 0x53, 0xa0, 0x10,
	0x4f, 0x09, 0xdc, 0x93, 0x96, 0x1f, 0xb8, 0x03, 0xcc, 0x6b, 0xd7, 0x68, 0x01, 0xad, 0x41, 0x91,
	0xd9, 0x82, 0x4b, 0x97, 0xc5, 0x8a, 0x63, 0x10, 0xdc, 0xae, 0xeb, 0x12, 0x97, 0x2a, 0x8c, 0xc7,
	0x65, 0x18, 0x86, 0x0d, 0x8b, 0xbb, 0xee, 0xf0, 0x4c, 0xf6, 0xfc, 0xcb, 0x90, 0xf7, 0xbd, 0x76,
	0xda, 0xf1, 0xc9, 0x2a, 0x01, 0x76, 0x7c, 0x31, 0x57, 0x92, 0x81, 0x1d, 0x3f, 0x20, 0x47, 0x08,
	0xf5, 0x2a, 0x8e, 0x10, 0x2e, 0x48, 0xed, 0xc6, 0xec, 0xf7, 0xcc, 0xf8, 0x4f, 0xd6, 0x6e, 0x9c,
	0xe3, 0x66, 0x22, 0x50, 0xbb, 0x23, 0xc7, 0xe1, 0x01, 0x9e, 0x3e, 0x93, 0x5c, 0xd2, 0xb7, 0xfd,
	0xc0, 0xf5, 0xce, 0x78, 0x8c, 0x10, 0xaf, 0xc6, 0x26, 0x2c, 0xfe, 0x8b, 0xe5, 0xbc, 0x3a, 0x87,
	0x44, 0x47, 0xb0, 0xf8, 0xd8, 0x71, 0x5b, 0x32, 0xc5, 0x4c, 0xf5, 0x4f, 0x0d, 0x4a, 0x43, 0x2b,
	0x08, 0xb0, 0x27, 0x0a, 0x3f, 0xf1, 0x4a, 0x9a, 0x46, 0x31, 0x0a, 0xf1, 0xc3, 0x61, 0x47, 0xaa,
	0x65, 0x12, 0x28, 0x6c, 0xd8, 0x41, 0x2b, 0x87, 0x53, 0x58, 0xdc, 0xb3, 0xbb, 0x5d, 0x59, 0x94,
	0x9b, 0xa0, 0x0d, 0xf0, 0x69, 0x33, 0xfb, 0x00, 0xa5, 0x01, 0x3e, 0xa5, 0x73, 0xfc, 0x9b, 0xa0,
	0xb9, 0x4e, 0x87, 0x61, 0xa5, 0x4c, 0x59, 0x72, 0x9d, 0x0e, 0xc5, 0xaa, 0x41, 0xc9, 0xef, 0x5b,
	0x8e, 0xe3, 0x9e, 0x72, 0x63, 0x8a, 0x57, 0xe3, 0x25, 0xe8, 0xd1, 0xc6, 0x51, 0xaf, 0x27, 0x76,
	0xf6, 0xc7, 0x08, 0xce, 0xb7, 0xa7, 0x87, 0x14, 0xfb, 0x8b, 0xbb, 0x91, 0xc4, 0xe5, 0x42, 0xf8,
	0xc6, 0x96, 0xe8, 0x0b, 0xcf, 0x61, 0xa3, 0x6b, 0x50, 0x39, 0xf0, 0xc9, 0x6d, 0x65, 0xd8, 0x3a,
	0xe4, 0xbb, 0xf6, 0x1b, 0x7e, 0x39, 0xc9, 0xa3, 0xf1, 0x25, 0x54, 0x19, 0x02, 0x17, 0x5e, 0xc2,
	0x28, 0x53, 0x0c, 0x5a, 0x01, 0x7b, 0x9e, 0x1b, 0xb6, 0xe9, 0xf4, 0xc5, 0x78, 0x0c, 0x48, 0x88,
	0xf8, 0x1c, 0x9f, 0x36, 0x02, 0xd7, 0xb3, 0x7a, 0x78, 0x06, 0x8f, 0x94, 0x82, 0x16, 0x1b, 0xe5,
	0x3c, 0xa1, 0xf1, 0xef, 0xd8, 0xf2, 0xce, 0xe5, 0x43, 0x08, 0xd4, 0x8e, 0x15, 0x58, 0x94, 0x53,
	0xd5, 0xa4, 0xcf, 0xc6, 0x3a, 0xcc, 0x3f, 0xc6, 0x32, 0xa7, 0x29, 0xba, 0xf9, 0x27, 0xa8, 0x31,
	0xfc, 0x5d, 0x77, 0xd0, 0xb1, 0x49, 0xd7, 0x61, 0x39, 0xb3, 0x5f, 0x2d, 0xff, 0x95, 0x3d, 0x14,
	0x57, 0x8b, 0x3c, 0x1b, 0xa7, 0x70, 0x29, 0x83, 0x1d, 0x57, 0xeb, 0xe7, 0x71, 0x67, 0x26, 0x4c,
	0x2f, 0xc6, 0xec, 0x1c, 0x29, 0x31, 0x72, 0xeb, 0xac, 0x53, 0x12, 0x03, 0x61, 0xb7, 0x2b, 0x7a,
	0x7a, 0xec, 0x76, 0x8d, 0x3e, 0xe8, 0x47, 0xa3, 0x80, 0xb7, 0x35, 0x5c, 0xfe, 0x30, 0x2b, 0x2b,
	0x72, 0x56, 0x7e, 0x0f, 0xd4, 0xc0, 0xea, 0x09, 0x47, 0xd3, 0xa8, 0x00, 0xc7, 0x56, 0xcf, 0xa4,
	0xab, 0xd1, 0x3c, 0x2c, 0x3f, 0x66, 0x1e, 0x66, 0x74, 0x45, 0x7d, 0x1e, 0xdf, 0xec, 0xef, 0x3e,
	0xf2, 0xfa, 0x5f, 0x05, 0x96, 0x1e, 0x63, 0x7e, 0x24, 0x5f, 0xaa, 0x24, 0xc5, 0x70, 0x51, 0x99,
	0x30, 0x5c, 0xcc, 0x2a, 0x96, 0xd4, 0x69, 0xc5, 0x52, 0xac, 0xe7, 0xbb, 0x02, 0x40, 0x87, 0xb8,
	0x4d, 0xb2, 0xc4, 0xdb, 0x9f, 0x32, 0x5d, 0x69, 0xd8, 0x3f, 0x61, 0xe3, 0x10, 0x16, 0x8f, 0x46,
	0x01, 0x17, 0x9b, 0x89, 0x36, 0x7d, 0x94, 0x18, 0x1a, 0x24, 0x27, 0x19, 0xc4, 0xd8, 0x86, 0xc5,
	0xc7, 0xf8, 0x9c, 0xac, 0x8c, 0xff, 0x53, 0x40, 0x17, 0x54, 0xa1, 0x72, 0x62, 0x23, 0x55, 0x65,
	0xca, 0x48, 0xf5, 0x1f, 0xae, 0x22, 0xc4, 0x46, 0x60, 0xf2, 0xc1, 0x8c, 0xef, 0x40, 0x3f, 0xb6,
	0x7a, 0xef, 0xe0, 0x39, 0x13, 0xbd, 0xd6, 0x58, 0x01, 0x44, 0xb6, 0x8a, 0xfb, 0x0a, 0xc9, 0x4d,
	0x64, 0xf5, 0xd8, 0xea, 0x85, 0x1a, 0x5a, 0x85, 0x22, 0x9b, 0x99, 0xf2, 0xe0, 0xc6, 0xdf, 0xd8,
	0x44, 0xb5, 0xed, 0x8c, 0x3a, 0xb8, 0xc9, 0x65, 0x61, 0xb7, 0x7a, 0x9e, 0xaf, 0x32, 0xce, 0x46,
	0x83, 0x1d, 0x89, 0x71, 0xe4, 0xb7, 0xba, 0x0e, 0xf9, 0xc0, 0xea, 0x71, 0xd9, 0x23, 0xc1, 0xc8,
	0xa2, 0x74, 0xb4, 0xdc, 0xd8, 0xa3, 0x19, 0x0f, 0x60, 0x85, 0x85, 0xf4, 0x77, 0x72, 0x75, 0xe3,
	0x22, 0x5c, 0x48, 0x90, 0x33, 0xc1, 0x8c, 0xcf, 0x44, 0xaa, 0x90, 0x15, 0x20, 0xf4, 0xa8, 0x8c,
	0xd3, 0xa3, 0x4c, 0xc2, 0x19, 0xdd, 0x05, 0xb4, 0xdb, 0xc7, 0xed, 0x57, 0xe7, 0x37, 0x9b, 0xf1,
	0x29, 0x2c, 0xc7, 0x48, 0xb9, 0xce, 0x56, 0xa1, 0x88, 0xdf, 0xd8, 0x7e, 0xe0, 0xf3, 0x2c, 0xc4,
	0xdf, 0x8c, 0x4d, 0x28, 0xf1, 0x53, 0xcc, 0x7a, 0xfa, 0x07, 0xb0, 0xcc, 0xe2, 0xde, 0x1e, 0xfd,
	0xf4, 0x2f, 0xe5, 0x38, 0xb7, 0xf5, 0x52, 0x64, 0x30, 0xb7, 0xf5, 0x72, 0xcc, 0xdd, 0xfb, 0x10,
	0x96, 0x59, 0x8c, 0x99, 0x42, 0x6e, 0xfc, 0x77, 0x0e, 0x2a, 0x62, 0xc0, 0x4f, 0x4a, 0xe4, 0xaf,
	0x92, 0xe2, 0x5d, 0x91, 0xc4, 0xa3, 0x28, 0xfc, 0xd9, 0xdf, 0x1f, 0x04, 0xde, 0x59, 0x14, 0x99,
	0xd6, 0x63, 0x8e, 0x5c, 0x4f, 0x51, 0x11, 0xcd, 0x33, 0x12, 0x8a, 0x57, 0x3f, 0x84, 0xaa, 0xcc,
	0x88, 0x88, 0xf6, 0x0a, 0x9f, 0x09, 0xd1, 0x5e, 0xe1, 0x33, 0x74, 0x43, 0x3e, 0x59, 0xea, 0xc6,
	0x33, 0xd8, 0xbd, 0xdc, 0x1d, 0xa5, 0xbe, 0x07, 0xe5, 0x90, 0x7b, 0x06, 0x9f, 0xf7, 0xe3, 0x7c,
	0xe2, 0xc3, 0xb4, 0x90, 0xcb, 0xda, 0x1a, 0x40, 0xf4, 0x0d, 0x1c, 0x69, 0xa0, 0x7e, 0xd7, 0xd8,
	0x37, 0xf5, 0x39, 0xf2, 0xf4, 0xe8, 0xbb, 0xe3, 0x17, 0xba, 0x42, 0x9e, 0x0e, 0x1a, 0xbb, 0xdf,
	0xea, 0xb9, 0xb5, 0x8f, 0xd9, 0x67, 0x2d, 0xfa, 0x2d, 0xaa, 0x0a, 0x9a, 0xb9, 0xdf, 0xd8, 0x37,
	0xbf, 0xdf, 0xdf, 0x63, 0xd8, 0x07, 0x87, 0xcf, 0xf6, 0x75, 0x05, 0x95, 0x20, 0xbf, 0x77, 0x68,
	0xea, 0xb9, 0xb5, 0x6d, 0x31, 0x3a, 0xa2, 0x7d, 0x32, 0xaa, 0x40, 0xa9, 0x71, 0xfc, 0xc8, 0x3c,
	0xa6, 0xe8, 0x65, 0x28, 0x98, 0xfb, 0x8f, 0xf6, 0xfe, 0x4d, 0x57, 0x08, 0x9f, 0x83, 0xc3, 0xe7,
	0x87, 0x8d, 0x27, 0xfb, 0x7b, 0x7a, 0x6e, 0xed, 0x3e, 0x94, 0xc3, 0xee, 0x90, 0x30, 0x7d, 0xfe,
	0xe2, 0xf9, 0x3e, 0x63, 0xff, 0xb4, 0xf1, 0xe2, 0x39, 0x13, 0xe6, 0xd9, 0xe1, 0xf3, 0x7d, 0x3d,
	0x47, 0x36, 0x6a, 0xfc, 0xf3, 0x33, 0x3d, 0x4f, 0x1e, 0x76, 0x1b, 0xdf, 0xeb, 0xea, 0xd6, 0xcf,
	0x3a, 0xe4, 0x1f, 0x1d, 0x1d, 0xa2, 0x6f, 0x00, 0xa2, 0xcf, 0x0d, 0x68, 0x95, 0xd5, 0x1a, 0xc9,
	0xef, 0x0f, 0xf5, 0xd5, 0xd4, 0x60, 0x74, 0x9f, 0xce, 0x01, 0xe7, 0xd0, 0x57, 0x50, 0x91, 0x3e,
	0x1d, 0x20, 0x96, 0xd4, 0xd3, 0x1f, 0x13, 0xea, 0xf1, 0x69, 0xbf, 0x31, 0x87, 0xee, 0x82, 0x26,
	0xbe, 0x12, 0xa0, 0x15, 0x0a, 0x4c, 0x7c, 0x4d, 0xa8, 0x5f, 0x48, 0xac, 0xf2, 0x2b, 0x39, 0x47,
	0x64, 0x8e, 0x3e, 0x10, 0x70, 0x99, 0x53, 0x5f, 0x0c, 0x26, 0xc8, 0xfc, 0x05, 0x54, 0xa4, 0x6f,
	0x00, 0x5c, 0xe6, 0xf4, 0x57, 0x81, 0xba, 0x5c, 0x79, 0x19, 0x73, 0x68, 0x07, 0xaa, 0xf2, 0xc0,
	0x17, 0xd5, 0x78, 0x01, 0x93, 0x9a, 0x01, 0x4f, 0xd8, 0xfa, 0x01, 0xcc, 0xc7, 0x06, 0xa7, 0xe8,
	0x92, 0xac, 0xb0, 0x38, 0x97, 0xe4, 0xac, 0xd0, 0x98, 0x43, 0x77, 0x00, 0xa2, 0x31, 0x28, 0x3f,
	0x79, 0x6a, 0x2e, 0x5a, 0xd7, 0x13, 0x84, 0xbe, 0x31, 0x87, 0x1e, 0xb2, 0xf0, 0x2d, 0xbc, 0xcc,
	0xc3, 0xd6, 0xc9, 0x58, 0xfa, 0xf4, 0xc6, 0x9b, 0x0a, 0x39, 0xbd, 0x3c, 0x19, 0xe3, 0xa7, 0xcf,
	0x18, 0x96, 0x4d, 0x38, 0xfd, 0x7d, 0xa8, 0x48, 0x13, 0x32, 0xae, 0xf8, 0xf4, 0xcc, 0x2c, 0x5b,
	0x80, 0x5d, 0x58, 0x4c, 0x8c, 0xbe, 0xd0, 0x65, 0x66, 0xb9, 0xcc, 0x81, 0x58, 0x36, 0x93, 0x2f,
	0xa0, 0x22, 0x7d, 0x4b, 0xe1, 0x12, 0xa4, 0xbf, 0xae, 0x64, 0x98, 0x5e, 0x1e, 0xcc, 0xf2, 0xc3,
	0x67, 0xcc, 0x6a, 0x67, 0x32, 0x3d, 0x67, 0x12, 0x33, 0x7d, 0x9c, 0x4b, 0xf2, 0x6f, 0xb0, 0x22,
	0xd3, 0x73, 0xda, 0xc8, 0x74, 0x71, 0x42, 0x3d, 0x41, 0xe8, 0x33, 0xe1, 0xe5, 0x29, 0x69, 0xcc,
	0x72, 0xb3, 0x0a, 0x7f, 0x0f, 0x4a, 0x7c, 0x6c, 0x80, 0x96, 0xe3, 0x43, 0x84, 0x29, 0x94, 0xb7,
	0x15, 0x74, 0x0f, 0x34, 0x31, 0x59, 0xe0, 0x37, 0x3d, 0x31, 0x68, 0x98, 0xb0, 0xef, 0x43, 0x28,
	0xf1, 0x51, 0x21, 0xdf, 0x37, 0x3e, 0x38, 0xac, 0x5f, 0x4e, 0x51, 0xd2, 0xfa, 0xec, 0x7b, 0x9a,
	0xe1, 0x88, 0xc1, 0xa3, 0xf8, 0x44, 0x99, 0xc4, 0xe2, 0x93, 0xcc, 0x28, 0xde, 0x75, 0x1a, 0x73,
	0x68, 0x8b, 0xc5, 0x27, 0x49, 0xea, 0xc4, 0xf8, 0xa1, 0xbe, 0x10, 0x23, 0xf1, 0x69, 0x4c, 0x5b,
	0x10, 0x48, 0xfc, 0x8a, 0x65, 0x53, 0x26, 0x37, 0xdb, 0x54, 0xd0, 0x36, 0x68, 0x62, 0xfc, 0xc0,
	0x89, 0x12, 0xd3, 0x88, 0x2c, 0xa2, 0x2d, 0xd0, 0xc4, 0x04, 0x82, 0x13, 0x25, 0x06, 0x12, 0xd9,
	0x32, 0x0a, 0xa4, 0x98, 0x8c, 0x49, 0xca, 0x8c, 0xed, 0xee, 0x82, 0x26, 0x9a, 0x7d, 0x4e, 0x94,
	0x18, 0x3a, 0xf0, 0x90, 0x9d, 0x9c, 0x08, 0xc8, 0x21, 0x9b, 0x12, 0xcb, 0x21, 0x7b, 0x36, 0x3f,
	0x78, 0x40, 0x73, 0x1d, 0x0e, 0xf0, 0x23, 0xc7, 0x41, 0x63, 0xd0, 0x26, 0x90, 0x6f, 0x80, 0x4a,
	0xba, 0x7c, 0xc4, 0xae, 0x87, 0x34, 0x11, 0xa8, 0x2f, 0x49, 0x2b, 0x42, 0xda, 0x4d, 0x05, 0xdd,
	0x81, 0x22, 0xeb, 0xca, 0x51, 0x38, 0x33, 0x8b, 0x1a, 0xeb, 0x89, 0xde, 0xfe, 0x00, 0x8a, 0xac,
	0x0d, 0xe6, 0x94, 0xb1, 0x96, 0x7c, 0xba, 0xbf, 0xfe, 0x2b, 0xed, 0xfc, 0xe2, 0x5d, 0x34, 0xba,
	0x22, 0x71, 0x4a, 0x37, 0xeb, 0xf5, 0xab, 0xe3, 0xc0, 0xe2, 0x40, 0xb7, 0x95, 0x4d, 0x05, 0x3d,
	0x64, 0x01, 0x84, 0xe8, 0xfb, 0x79, 0x63, 0x8c, 0x63, 0x8e, 0xeb, 0xc9, 0x89, 0x68, 0x5b, 0x6f,
	0x01, 0xca, 0xac, 0x26, 0x22, 0x85, 0xc3, 0x36, 0x94, 0xc3, 0xae, 0x1b, 0x5d, 0x10, 0x4a, 0x8a,
	0xd5, 0xc9, 0x75, 0xb9, 0x8e, 0xa2, 0xca, 0xb9, 0x4b, 0x07, 0xa6, 0x6c, 0xa1, 0x41, 0x47, 0xa3,
	0x63, 0x28, 0xab, 0x12, 0xa5, 0x4f, 0x49, 0x1f, 0x02, 0x84, 0x58, 0xfe, 0x38, 0xb2, 0x49, 0x86,
	0x09, 0x63, 0x38, 0x97, 0x59, 0x8e, 0xe1, 0x33, 0x72, 0x41, 0x77, 0xa1, 0x1c, 0xf6, 0xe5, 0x48,
	0x3e, 0xdd, 0x74, 0xc3, 0xee, 0x03, 0x44, 0x2d, 0x3d, 0xbf, 0x01, 0xa9, 0x1e, 0x7f, 0x3a, 0x9b,
	0xaf, 0x41, 0x13, 0xcd, 0x37, 0xb7, 0x61, 0xa2, 0x17, 0x9f, 0xa8, 0x83, 0x47, 0xa0, 0x89, 0xce,
	0x59, 0x5c, 0xfb, 0x78, 0xfb, 0x3d, 0x5d, 0x80, 0x5d, 0xaa, 0x02, 0xd6, 0x7c, 0x73, 0x33, 0x24,
	0x9b, 0xf1, 0xe9, 0x4c, 0xb6, 0xa0, 0x1c, 0xf6, 0xc7, 0x28, 0xaa, 0xf3, 0x62, 0x92, 0x48, 0x9d,
	0x3f, 0x3f, 0x79, 0x39, 0xec, 0x9f, 0x39, 0x4d, 0xb2, 0x9f, 0x9e, 0x18, 0x01, 0x44, 0xf6, 0xcd,
	0xb2, 0xde, 0x62, 0xac, 0x17, 0xa1, 0xf1, 0x7f, 0x07, 0x2a, 0x52, 0xfb, 0xc6, 0x13, 0x47, 0xba,
	0x17, 0xac, 0xd7, 0xd2, 0x80, 0x30, 0xea, 0xdd, 0x87, 0x8a, 0xd4, 0x9b, 0x73, 0x1e, 0xe9, 0x6e,
	0x3d, 0x63, 0xfb, 0x4d, 0x05, 0x3d, 0x81, 0xf9, 0x58, 0x73, 0xcb, 0xeb, 0x85, 0xac, 0x7e, 0xb9,
	0x5e, 0xcf, 0x02, 0x85, 0x62, 0x6c, 0xf3, 0x90, 0xd4, 0x43, 0x61, 0xd3, 0x3b, 0xdd, 0x44, 0x1f,
	0x01, 0x70, 0x85, 0xc5, 0x09, 0x33, 0x54, 0x75, 0x9f, 0xa5, 0x4a, 0xd2, 0x60, 0x49, 0x71, 0x45,
	0x6a, 0xbd, 0xa5, 0x52, 0x3e, 0xd6, 0x5d, 0xcf, 0xb1, 0xb0, 0x14, 0xf5, 0xdd, 0xb1, 0xcc, 0x20,
	0x33, 0xb8, 0x98, 0x5a, 0x97, 0x94, 0x5c, 0xe2, 0x7f, 0xca, 0xf5, 0x0e, 0x89, 0x61, 0x0f, 0xaa,
	0x72, 0x0f, 0xcd, 0x83, 0x42, 0x46, 0x5b, 0x3d, 0xf1, 0x5a, 0x1d, 0x42, 0x55, 0x6e, 0xa5, 0x39,
	0x97, 0x8c, 0xee, 0x7a, 0xaa, 0xda, 0x77, 0xee, 0xff, 0xee, 0xed, 0x55, 0xe5, 0x8f, 0x6f, 0xaf,
	0x2a, 0x7f, 0x7e, 0x7b, 0x55, 0xf9, 0xe1, 0xd3, 0x9e, 0x1d, 0xf4, 0x47, 0xad, 0xf5, 0xb6, 0x7b,
	0xb2, 0x31, 0xb4, 0xda, 0xfd, 0xb3, 0x0e, 0xf6, 0xe4, 0x27, 0xdf, 0x6b, 0x6f, 0x44, 0xff, 0x9e,
	0xa3, 0x55, 0xa4, 0x5c, 0xb7, 0xff, 0x16, 0x00, 0x00, 0xff, 0xff, 0x26, 0x1f, 0xeb, 0x54, 0xe4,
	0x31, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// APIClient is the client API for API service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type APIClient interface {
	// Repo rpcs
	// CreateRepo creates a new repo.
	// An error is returned if the repo already exists.
	CreateRepo(ctx context.Context, in *CreateRepoRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// InspectRepo returns info about a repo.
	InspectRepo(ctx context.Context, in *InspectRepoRequest, opts ...grpc.CallOption) (*RepoInfo, error)
	// ListRepo returns info about all repos.
	ListRepo(ctx context.Context, in *ListRepoRequest, opts ...grpc.CallOption) (*ListRepoResponse, error)
	// DeleteRepo deletes a repo.
	DeleteRepo(ctx context.Context, in *DeleteRepoRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// Commit rpcs
	// StartCommit creates a new write commit from a parent commit.
	StartCommit(ctx context.Context, in *StartCommitRequest, opts ...grpc.CallOption) (*Commit, error)
	// FinishCommit turns a write commit into a read commit.
	FinishCommit(ctx context.Context, in *FinishCommitRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// InspectCommit returns the info about a commit.
	InspectCommit(ctx context.Context, in *InspectCommitRequest, opts ...grpc.CallOption) (*CommitInfo, error)
	// ListCommit returns info about all commits. This is deprecated in favor of
	// ListCommitStream.
	ListCommit(ctx context.Context, in *ListCommitRequest, opts ...grpc.CallOption) (*CommitInfos, error)
	// ListCommitStream is like ListCommit, but returns its results in a GRPC stream
	ListCommitStream(ctx context.Context, in *ListCommitRequest, opts ...grpc.CallOption) (API_ListCommitStreamClient, error)
	// DeleteCommit deletes a commit.
	DeleteCommit(ctx context.Context, in *DeleteCommitRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// FlushCommit waits for downstream commits to finish
	FlushCommit(ctx context.Context, in *FlushCommitRequest, opts ...grpc.CallOption) (API_FlushCommitClient, error)
	// SubscribeCommit subscribes for new commits on a given branch
	SubscribeCommit(ctx context.Context, in *SubscribeCommitRequest, opts ...grpc.CallOption) (API_SubscribeCommitClient, error)
	// BuildCommit builds a commit that's backed by the given tree
	BuildCommit(ctx context.Context, in *BuildCommitRequest, opts ...grpc.CallOption) (*Commit, error)
	// CreateBranch creates a new branch
	CreateBranch(ctx context.Context, in *CreateBranchRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// InspectBranch returns info about a branch.
	InspectBranch(ctx context.Context, in *InspectBranchRequest, opts ...grpc.CallOption) (*BranchInfo, error)
	// ListBranch returns info about the heads of branches.
	ListBranch(ctx context.Context, in *ListBranchRequest, opts ...grpc.CallOption) (*BranchInfos, error)
	// DeleteBranch deletes a branch; note that the commits still exist.
	DeleteBranch(ctx context.Context, in *DeleteBranchRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// File rpcs
	// PutFile writes the specified file to pfs.
	PutFile(ctx context.Context, opts ...grpc.CallOption) (API_PutFileClient, error)
	// CopyFile copies the contents of one file to another.
	CopyFile(ctx context.Context, in *CopyFileRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// GetFile returns a byte stream of the contents of the file.
	GetFile(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (API_GetFileClient, error)
	// InspectFile returns info about a file.
	InspectFile(ctx context.Context, in *InspectFileRequest, opts ...grpc.CallOption) (*FileInfo, error)
	// ListFile returns info about all files. This is deprecated in favor of
	// ListFileStream
	ListFile(ctx context.Context, in *ListFileRequest, opts ...grpc.CallOption) (*FileInfos, error)
	// ListFileStream is a streaming version of ListFile
	// TODO(msteffen): When the dash has been updated to use ListFileStream,
	// replace ListFile with this RPC (https://github.com/pachyderm/dash/issues/201)
	ListFileStream(ctx context.Context, in *ListFileRequest, opts ...grpc.CallOption) (API_ListFileStreamClient, error)
	// WalkFile walks over all the files under a directory, including children of children.
	WalkFile(ctx context.Context, in *WalkFileRequest, opts ...grpc.CallOption) (API_WalkFileClient, error)
	// GlobFile returns info about all files. This is deprecated in favor of
	// GlobFileStream
	GlobFile(ctx context.Context, in *GlobFileRequest, opts ...grpc.CallOption) (*FileInfos, error)
	// GlobFileStream is a streaming version of GlobFile
	// TODO(msteffen): When the dash has been updated to use GlobFileStream,
	// replace GlobFile with this RPC (https://github.com/pachyderm/dash/issues/201)
	GlobFileStream(ctx context.Context, in *GlobFileRequest, opts ...grpc.CallOption) (API_GlobFileStreamClient, error)
	// DiffFile returns the differences between 2 paths at 2 commits.
	DiffFile(ctx context.Context, in *DiffFileRequest, opts ...grpc.CallOption) (*DiffFileResponse, error)
	// DeleteFile deletes a file.
	DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// DeleteAll deletes everything
	DeleteAll(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*types.Empty, error)
	// Fsck does a file system consistency check for pfs
	Fsck(ctx context.Context, in *FsckRequest, opts ...grpc.CallOption) (API_FsckClient, error)
	// RPCs specific to the new storage layer.
	PutTar(ctx context.Context, opts ...grpc.CallOption) (API_PutTarClient, error)
	GetTar(ctx context.Context, in *GetTarRequest, opts ...grpc.CallOption) (API_GetTarClient, error)
	// Refer to the GetTarConditionalRequest / GetTarConditionalResponse message definitions for the protocol.
	GetTarConditional(ctx context.Context, opts ...grpc.CallOption) (API_GetTarConditionalClient, error)
	ListFileNS(ctx context.Context, in *ListFileRequest, opts ...grpc.CallOption) (API_ListFileNSClient, error)
}

type aPIClient struct {
	cc *grpc.ClientConn
}

func NewAPIClient(cc *grpc.ClientConn) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) CreateRepo(ctx context.Context, in *CreateRepoRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/CreateRepo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectRepo(ctx context.Context, in *InspectRepoRequest, opts ...grpc.CallOption) (*RepoInfo, error) {
	out := new(RepoInfo)
	err := c.cc.Invoke(ctx, "/pfs.API/InspectRepo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListRepo(ctx context.Context, in *ListRepoRequest, opts ...grpc.CallOption) (*ListRepoResponse, error) {
	out := new(ListRepoResponse)
	err := c.cc.Invoke(ctx, "/pfs.API/ListRepo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteRepo(ctx context.Context, in *DeleteRepoRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/DeleteRepo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) StartCommit(ctx context.Context, in *StartCommitRequest, opts ...grpc.CallOption) (*Commit, error) {
	out := new(Commit)
	err := c.cc.Invoke(ctx, "/pfs.API/StartCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) FinishCommit(ctx context.Context, in *FinishCommitRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/FinishCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectCommit(ctx context.Context, in *InspectCommitRequest, opts ...grpc.CallOption) (*CommitInfo, error) {
	out := new(CommitInfo)
	err := c.cc.Invoke(ctx, "/pfs.API/InspectCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListCommit(ctx context.Context, in *ListCommitRequest, opts ...grpc.CallOption) (*CommitInfos, error) {
	out := new(CommitInfos)
	err := c.cc.Invoke(ctx, "/pfs.API/ListCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListCommitStream(ctx context.Context, in *ListCommitRequest, opts ...grpc.CallOption) (API_ListCommitStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[0], "/pfs.API/ListCommitStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListCommitStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListCommitStreamClient interface {
	Recv() (*CommitInfo, error)
	grpc.ClientStream
}

type aPIListCommitStreamClient struct {
	grpc.ClientStream
}

func (x *aPIListCommitStreamClient) Recv() (*CommitInfo, error) {
	m := new(CommitInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) DeleteCommit(ctx context.Context, in *DeleteCommitRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/DeleteCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) FlushCommit(ctx context.Context, in *FlushCommitRequest, opts ...grpc.CallOption) (API_FlushCommitClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[1], "/pfs.API/FlushCommit", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIFlushCommitClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_FlushCommitClient interface {
	Recv() (*CommitInfo, error)
	grpc.ClientStream
}

type aPIFlushCommitClient struct {
	grpc.ClientStream
}

func (x *aPIFlushCommitClient) Recv() (*CommitInfo, error) {
	m := new(CommitInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) SubscribeCommit(ctx context.Context, in *SubscribeCommitRequest, opts ...grpc.CallOption) (API_SubscribeCommitClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[2], "/pfs.API/SubscribeCommit", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPISubscribeCommitClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_SubscribeCommitClient interface {
	Recv() (*CommitInfo, error)
	grpc.ClientStream
}

type aPISubscribeCommitClient struct {
	grpc.ClientStream
}

func (x *aPISubscribeCommitClient) Recv() (*CommitInfo, error) {
	m := new(CommitInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) BuildCommit(ctx context.Context, in *BuildCommitRequest, opts ...grpc.CallOption) (*Commit, error) {
	out := new(Commit)
	err := c.cc.Invoke(ctx, "/pfs.API/BuildCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CreateBranch(ctx context.Context, in *CreateBranchRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/CreateBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectBranch(ctx context.Context, in *InspectBranchRequest, opts ...grpc.CallOption) (*BranchInfo, error) {
	out := new(BranchInfo)
	err := c.cc.Invoke(ctx, "/pfs.API/InspectBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListBranch(ctx context.Context, in *ListBranchRequest, opts ...grpc.CallOption) (*BranchInfos, error) {
	out := new(BranchInfos)
	err := c.cc.Invoke(ctx, "/pfs.API/ListBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteBranch(ctx context.Context, in *DeleteBranchRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/DeleteBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) PutFile(ctx context.Context, opts ...grpc.CallOption) (API_PutFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[3], "/pfs.API/PutFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIPutFileClient{stream}
	return x, nil
}

type API_PutFileClient interface {
	Send(*PutFileRequest) error
	CloseAndRecv() (*types.Empty, error)
	grpc.ClientStream
}

type aPIPutFileClient struct {
	grpc.ClientStream
}

func (x *aPIPutFileClient) Send(m *PutFileRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *aPIPutFileClient) CloseAndRecv() (*types.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(types.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) CopyFile(ctx context.Context, in *CopyFileRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/CopyFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GetFile(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (API_GetFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[4], "/pfs.API/GetFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIGetFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_GetFileClient interface {
	Recv() (*types.BytesValue, error)
	grpc.ClientStream
}

type aPIGetFileClient struct {
	grpc.ClientStream
}

func (x *aPIGetFileClient) Recv() (*types.BytesValue, error) {
	m := new(types.BytesValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) InspectFile(ctx context.Context, in *InspectFileRequest, opts ...grpc.CallOption) (*FileInfo, error) {
	out := new(FileInfo)
	err := c.cc.Invoke(ctx, "/pfs.API/InspectFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListFile(ctx context.Context, in *ListFileRequest, opts ...grpc.CallOption) (*FileInfos, error) {
	out := new(FileInfos)
	err := c.cc.Invoke(ctx, "/pfs.API/ListFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListFileStream(ctx context.Context, in *ListFileRequest, opts ...grpc.CallOption) (API_ListFileStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[5], "/pfs.API/ListFileStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListFileStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListFileStreamClient interface {
	Recv() (*FileInfo, error)
	grpc.ClientStream
}

type aPIListFileStreamClient struct {
	grpc.ClientStream
}

func (x *aPIListFileStreamClient) Recv() (*FileInfo, error) {
	m := new(FileInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) WalkFile(ctx context.Context, in *WalkFileRequest, opts ...grpc.CallOption) (API_WalkFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[6], "/pfs.API/WalkFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIWalkFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_WalkFileClient interface {
	Recv() (*FileInfo, error)
	grpc.ClientStream
}

type aPIWalkFileClient struct {
	grpc.ClientStream
}

func (x *aPIWalkFileClient) Recv() (*FileInfo, error) {
	m := new(FileInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) GlobFile(ctx context.Context, in *GlobFileRequest, opts ...grpc.CallOption) (*FileInfos, error) {
	out := new(FileInfos)
	err := c.cc.Invoke(ctx, "/pfs.API/GlobFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GlobFileStream(ctx context.Context, in *GlobFileRequest, opts ...grpc.CallOption) (API_GlobFileStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[7], "/pfs.API/GlobFileStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIGlobFileStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_GlobFileStreamClient interface {
	Recv() (*FileInfo, error)
	grpc.ClientStream
}

type aPIGlobFileStreamClient struct {
	grpc.ClientStream
}

func (x *aPIGlobFileStreamClient) Recv() (*FileInfo, error) {
	m := new(FileInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) DiffFile(ctx context.Context, in *DiffFileRequest, opts ...grpc.CallOption) (*DiffFileResponse, error) {
	out := new(DiffFileResponse)
	err := c.cc.Invoke(ctx, "/pfs.API/DiffFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/DeleteFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteAll(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/DeleteAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) Fsck(ctx context.Context, in *FsckRequest, opts ...grpc.CallOption) (API_FsckClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[8], "/pfs.API/Fsck", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIFsckClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_FsckClient interface {
	Recv() (*FsckResponse, error)
	grpc.ClientStream
}

type aPIFsckClient struct {
	grpc.ClientStream
}

func (x *aPIFsckClient) Recv() (*FsckResponse, error) {
	m := new(FsckResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) PutTar(ctx context.Context, opts ...grpc.CallOption) (API_PutTarClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[9], "/pfs.API/PutTar", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIPutTarClient{stream}
	return x, nil
}

type API_PutTarClient interface {
	Send(*PutTarRequest) error
	CloseAndRecv() (*types.Empty, error)
	grpc.ClientStream
}

type aPIPutTarClient struct {
	grpc.ClientStream
}

func (x *aPIPutTarClient) Send(m *PutTarRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *aPIPutTarClient) CloseAndRecv() (*types.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(types.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) GetTar(ctx context.Context, in *GetTarRequest, opts ...grpc.CallOption) (API_GetTarClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[10], "/pfs.API/GetTar", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIGetTarClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_GetTarClient interface {
	Recv() (*types.BytesValue, error)
	grpc.ClientStream
}

type aPIGetTarClient struct {
	grpc.ClientStream
}

func (x *aPIGetTarClient) Recv() (*types.BytesValue, error) {
	m := new(types.BytesValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) GetTarConditional(ctx context.Context, opts ...grpc.CallOption) (API_GetTarConditionalClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[11], "/pfs.API/GetTarConditional", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIGetTarConditionalClient{stream}
	return x, nil
}

type API_GetTarConditionalClient interface {
	Send(*GetTarConditionalRequest) error
	Recv() (*GetTarConditionalResponse, error)
	grpc.ClientStream
}

type aPIGetTarConditionalClient struct {
	grpc.ClientStream
}

func (x *aPIGetTarConditionalClient) Send(m *GetTarConditionalRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *aPIGetTarConditionalClient) Recv() (*GetTarConditionalResponse, error) {
	m := new(GetTarConditionalResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) ListFileNS(ctx context.Context, in *ListFileRequest, opts ...grpc.CallOption) (API_ListFileNSClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[12], "/pfs.API/ListFileNS", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListFileNSClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListFileNSClient interface {
	Recv() (*FileInfoNewStorage, error)
	grpc.ClientStream
}

type aPIListFileNSClient struct {
	grpc.ClientStream
}

func (x *aPIListFileNSClient) Recv() (*FileInfoNewStorage, error) {
	m := new(FileInfoNewStorage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// APIServer is the server API for API service.
type APIServer interface {
	// Repo rpcs
	// CreateRepo creates a new repo.
	// An error is returned if the repo already exists.
	CreateRepo(context.Context, *CreateRepoRequest) (*types.Empty, error)
	// InspectRepo returns info about a repo.
	InspectRepo(context.Context, *InspectRepoRequest) (*RepoInfo, error)
	// ListRepo returns info about all repos.
	ListRepo(context.Context, *ListRepoRequest) (*ListRepoResponse, error)
	// DeleteRepo deletes a repo.
	DeleteRepo(context.Context, *DeleteRepoRequest) (*types.Empty, error)
	// Commit rpcs
	// StartCommit creates a new write commit from a parent commit.
	StartCommit(context.Context, *StartCommitRequest) (*Commit, error)
	// FinishCommit turns a write commit into a read commit.
	FinishCommit(context.Context, *FinishCommitRequest) (*types.Empty, error)
	// InspectCommit returns the info about a commit.
	InspectCommit(context.Context, *InspectCommitRequest) (*CommitInfo, error)
	// ListCommit returns info about all commits. This is deprecated in favor of
	// ListCommitStream.
	ListCommit(context.Context, *ListCommitRequest) (*CommitInfos, error)
	// ListCommitStream is like ListCommit, but returns its results in a GRPC stream
	ListCommitStream(*ListCommitRequest, API_ListCommitStreamServer) error
	// DeleteCommit deletes a commit.
	DeleteCommit(context.Context, *DeleteCommitRequest) (*types.Empty, error)
	// FlushCommit waits for downstream commits to finish
	FlushCommit(*FlushCommitRequest, API_FlushCommitServer) error
	// SubscribeCommit subscribes for new commits on a given branch
	SubscribeCommit(*SubscribeCommitRequest, API_SubscribeCommitServer) error
	// BuildCommit builds a commit that's backed by the given tree
	BuildCommit(context.Context, *BuildCommitRequest) (*Commit, error)
	// CreateBranch creates a new branch
	CreateBranch(context.Context, *CreateBranchRequest) (*types.Empty, error)
	// InspectBranch returns info about a branch.
	InspectBranch(context.Context, *InspectBranchRequest) (*BranchInfo, error)
	// ListBranch returns info about the heads of branches.
	ListBranch(context.Context, *ListBranchRequest) (*BranchInfos, error)
	// DeleteBranch deletes a branch; note that the commits still exist.
	DeleteBranch(context.Context, *DeleteBranchRequest) (*types.Empty, error)
	// File rpcs
	// PutFile writes the specified file to pfs.
	PutFile(API_PutFileServer) error
	// CopyFile copies the contents of one file to another.
	CopyFile(context.Context, *CopyFileRequest) (*types.Empty, error)
	// GetFile returns a byte stream of the contents of the file.
	GetFile(*GetFileRequest, API_GetFileServer) error
	// InspectFile returns info about a file.
	InspectFile(context.Context, *InspectFileRequest) (*FileInfo, error)
	// ListFile returns info about all files. This is deprecated in favor of
	// ListFileStream
	ListFile(context.Context, *ListFileRequest) (*FileInfos, error)
	// ListFileStream is a streaming version of ListFile
	// TODO(msteffen): When the dash has been updated to use ListFileStream,
	// replace ListFile with this RPC (https://github.com/pachyderm/dash/issues/201)
	ListFileStream(*ListFileRequest, API_ListFileStreamServer) error
	// WalkFile walks over all the files under a directory, including children of children.
	WalkFile(*WalkFileRequest, API_WalkFileServer) error
	// GlobFile returns info about all files. This is deprecated in favor of
	// GlobFileStream
	GlobFile(context.Context, *GlobFileRequest) (*FileInfos, error)
	// GlobFileStream is a streaming version of GlobFile
	// TODO(msteffen): When the dash has been updated to use GlobFileStream,
	// replace GlobFile with this RPC (https://github.com/pachyderm/dash/issues/201)
	GlobFileStream(*GlobFileRequest, API_GlobFileStreamServer) error
	// DiffFile returns the differences between 2 paths at 2 commits.
	DiffFile(context.Context, *DiffFileRequest) (*DiffFileResponse, error)
	// DeleteFile deletes a file.
	DeleteFile(context.Context, *DeleteFileRequest) (*types.Empty, error)
	// DeleteAll deletes everything
	DeleteAll(context.Context, *types.Empty) (*types.Empty, error)
	// Fsck does a file system consistency check for pfs
	Fsck(*FsckRequest, API_FsckServer) error
	// RPCs specific to the new storage layer.
	PutTar(API_PutTarServer) error
	GetTar(*GetTarRequest, API_GetTarServer) error
	// Refer to the GetTarConditionalRequest / GetTarConditionalResponse message definitions for the protocol.
	GetTarConditional(API_GetTarConditionalServer) error
	ListFileNS(*ListFileRequest, API_ListFileNSServer) error
}

// UnimplementedAPIServer can be embedded to have forward compatible implementations.
type UnimplementedAPIServer struct {
}

func (*UnimplementedAPIServer) CreateRepo(ctx context.Context, req *CreateRepoRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRepo not implemented")
}
func (*UnimplementedAPIServer) InspectRepo(ctx context.Context, req *InspectRepoRequest) (*RepoInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectRepo not implemented")
}
func (*UnimplementedAPIServer) ListRepo(ctx context.Context, req *ListRepoRequest) (*ListRepoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRepo not implemented")
}
func (*UnimplementedAPIServer) DeleteRepo(ctx context.Context, req *DeleteRepoRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRepo not implemented")
}
func (*UnimplementedAPIServer) StartCommit(ctx context.Context, req *StartCommitRequest) (*Commit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartCommit not implemented")
}
func (*UnimplementedAPIServer) FinishCommit(ctx context.Context, req *FinishCommitRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishCommit not implemented")
}
func (*UnimplementedAPIServer) InspectCommit(ctx context.Context, req *InspectCommitRequest) (*CommitInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectCommit not implemented")
}
func (*UnimplementedAPIServer) ListCommit(ctx context.Context, req *ListCommitRequest) (*CommitInfos, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCommit not implemented")
}
func (*UnimplementedAPIServer) ListCommitStream(req *ListCommitRequest, srv API_ListCommitStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method ListCommitStream not implemented")
}
func (*UnimplementedAPIServer) DeleteCommit(ctx context.Context, req *DeleteCommitRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCommit not implemented")
}
func (*UnimplementedAPIServer) FlushCommit(req *FlushCommitRequest, srv API_FlushCommitServer) error {
	return status.Errorf(codes.Unimplemented, "method FlushCommit not implemented")
}
func (*UnimplementedAPIServer) SubscribeCommit(req *SubscribeCommitRequest, srv API_SubscribeCommitServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeCommit not implemented")
}
func (*UnimplementedAPIServer) BuildCommit(ctx context.Context, req *BuildCommitRequest) (*Commit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildCommit not implemented")
}
func (*UnimplementedAPIServer) CreateBranch(ctx context.Context, req *CreateBranchRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBranch not implemented")
}
func (*UnimplementedAPIServer) InspectBranch(ctx context.Context, req *InspectBranchRequest) (*BranchInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectBranch not implemented")
}
func (*UnimplementedAPIServer) ListBranch(ctx context.Context, req *ListBranchRequest) (*BranchInfos, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBranch not implemented")
}
func (*UnimplementedAPIServer) DeleteBranch(ctx context.Context, req *DeleteBranchRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBranch not implemented")
}
func (*UnimplementedAPIServer) PutFile(srv API_PutFileServer) error {
	return status.Errorf(codes.Unimplemented, "method PutFile not implemented")
}
func (*UnimplementedAPIServer) CopyFile(ctx context.Context, req *CopyFileRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyFile not implemented")
}
func (*UnimplementedAPIServer) GetFile(req *GetFileRequest, srv API_GetFileServer) error {
	return status.Errorf(codes.Unimplemented, "method GetFile not implemented")
}
func (*UnimplementedAPIServer) InspectFile(ctx context.Context, req *InspectFileRequest) (*FileInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectFile not implemented")
}
func (*UnimplementedAPIServer) ListFile(ctx context.Context, req *ListFileRequest) (*FileInfos, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFile not implemented")
}
func (*UnimplementedAPIServer) ListFileStream(req *ListFileRequest, srv API_ListFileStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method ListFileStream not implemented")
}
func (*UnimplementedAPIServer) WalkFile(req *WalkFileRequest, srv API_WalkFileServer) error {
	return status.Errorf(codes.Unimplemented, "method WalkFile not implemented")
}
func (*UnimplementedAPIServer) GlobFile(ctx context.Context, req *GlobFileRequest) (*FileInfos, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GlobFile not implemented")
}
func (*UnimplementedAPIServer) GlobFileStream(req *GlobFileRequest, srv API_GlobFileStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method GlobFileStream not implemented")
}
func (*UnimplementedAPIServer) DiffFile(ctx context.Context, req *DiffFileRequest) (*DiffFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DiffFile not implemented")
}
func (*UnimplementedAPIServer) DeleteFile(ctx context.Context, req *DeleteFileRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFile not implemented")
}
func (*UnimplementedAPIServer) DeleteAll(ctx context.Context, req *types.Empty) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAll not implemented")
}
func (*UnimplementedAPIServer) Fsck(req *FsckRequest, srv API_FsckServer) error {
	return status.Errorf(codes.Unimplemented, "method Fsck not implemented")
}
func (*UnimplementedAPIServer) PutTar(srv API_PutTarServer) error {
	return status.Errorf(codes.Unimplemented, "method PutTar not implemented")
}
func (*UnimplementedAPIServer) GetTar(req *GetTarRequest, srv API_GetTarServer) error {
	return status.Errorf(codes.Unimplemented, "method GetTar not implemented")
}
func (*UnimplementedAPIServer) GetTarConditional(srv API_GetTarConditionalServer) error {
	return status.Errorf(codes.Unimplemented, "method GetTarConditional not implemented")
}
func (*UnimplementedAPIServer) ListFileNS(req *ListFileRequest, srv API_ListFileNSServer) error {
	return status.Errorf(codes.Unimplemented, "method ListFileNS not implemented")
}

func RegisterAPIServer(s *grpc.Server, srv APIServer) {
	s.RegisterService(&_API_serviceDesc, srv)
}

func _API_CreateRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreateRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/CreateRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreateRepo(ctx, req.(*CreateRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/InspectRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectRepo(ctx, req.(*InspectRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/ListRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListRepo(ctx, req.(*ListRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/DeleteRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteRepo(ctx, req.(*DeleteRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_StartCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).StartCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/StartCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).StartCommit(ctx, req.(*StartCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_FinishCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).FinishCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/FinishCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).FinishCommit(ctx, req.(*FinishCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/InspectCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectCommit(ctx, req.(*InspectCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/ListCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListCommit(ctx, req.(*ListCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListCommitStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListCommitRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListCommitStream(m, &aPIListCommitStreamServer{stream})
}

type API_ListCommitStreamServer interface {
	Send(*CommitInfo) error
	grpc.ServerStream
}

type aPIListCommitStreamServer struct {
	grpc.ServerStream
}

func (x *aPIListCommitStreamServer) Send(m *CommitInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_DeleteCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/DeleteCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteCommit(ctx, req.(*DeleteCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_FlushCommit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FlushCommitRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).FlushCommit(m, &aPIFlushCommitServer{stream})
}

type API_FlushCommitServer interface {
	Send(*CommitInfo) error
	grpc.ServerStream
}

type aPIFlushCommitServer struct {
	grpc.ServerStream
}

func (x *aPIFlushCommitServer) Send(m *CommitInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_SubscribeCommit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeCommitRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).SubscribeCommit(m, &aPISubscribeCommitServer{stream})
}

type API_SubscribeCommitServer interface {
	Send(*CommitInfo) error
	grpc.ServerStream
}

type aPISubscribeCommitServer struct {
	grpc.ServerStream
}

func (x *aPISubscribeCommitServer) Send(m *CommitInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_BuildCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).BuildCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/BuildCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).BuildCommit(ctx, req.(*BuildCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CreateBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreateBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/CreateBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreateBranch(ctx, req.(*CreateBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/InspectBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectBranch(ctx, req.(*InspectBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/ListBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListBranch(ctx, req.(*ListBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/DeleteBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteBranch(ctx, req.(*DeleteBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_PutFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(APIServer).PutFile(&aPIPutFileServer{stream})
}

type API_PutFileServer interface {
	SendAndClose(*types.Empty) error
	Recv() (*PutFileRequest, error)
	grpc.ServerStream
}

type aPIPutFileServer struct {
	grpc.ServerStream
}

func (x *aPIPutFileServer) SendAndClose(m *types.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *aPIPutFileServer) Recv() (*PutFileRequest, error) {
	m := new(PutFileRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _API_CopyFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CopyFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/CopyFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CopyFile(ctx, req.(*CopyFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GetFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).GetFile(m, &aPIGetFileServer{stream})
}

type API_GetFileServer interface {
	Send(*types.BytesValue) error
	grpc.ServerStream
}

type aPIGetFileServer struct {
	grpc.ServerStream
}

func (x *aPIGetFileServer) Send(m *types.BytesValue) error {
	return x.ServerStream.SendMsg(m)
}

func _API_InspectFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/InspectFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectFile(ctx, req.(*InspectFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/ListFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListFile(ctx, req.(*ListFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListFileStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListFileStream(m, &aPIListFileStreamServer{stream})
}

type API_ListFileStreamServer interface {
	Send(*FileInfo) error
	grpc.ServerStream
}

type aPIListFileStreamServer struct {
	grpc.ServerStream
}

func (x *aPIListFileStreamServer) Send(m *FileInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_WalkFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WalkFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).WalkFile(m, &aPIWalkFileServer{stream})
}

type API_WalkFileServer interface {
	Send(*FileInfo) error
	grpc.ServerStream
}

type aPIWalkFileServer struct {
	grpc.ServerStream
}

func (x *aPIWalkFileServer) Send(m *FileInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_GlobFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GlobFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GlobFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/GlobFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GlobFile(ctx, req.(*GlobFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GlobFileStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GlobFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).GlobFileStream(m, &aPIGlobFileStreamServer{stream})
}

type API_GlobFileStreamServer interface {
	Send(*FileInfo) error
	grpc.ServerStream
}

type aPIGlobFileStreamServer struct {
	grpc.ServerStream
}

func (x *aPIGlobFileStreamServer) Send(m *FileInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_DiffFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiffFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DiffFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/DiffFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DiffFile(ctx, req.(*DiffFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/DeleteFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteFile(ctx, req.(*DeleteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/DeleteAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteAll(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_Fsck_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FsckRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).Fsck(m, &aPIFsckServer{stream})
}

type API_FsckServer interface {
	Send(*FsckResponse) error
	grpc.ServerStream
}

type aPIFsckServer struct {
	grpc.ServerStream
}

func (x *aPIFsckServer) Send(m *FsckResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _API_PutTar_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(APIServer).PutTar(&aPIPutTarServer{stream})
}

type API_PutTarServer interface {
	SendAndClose(*types.Empty) error
	Recv() (*PutTarRequest, error)
	grpc.ServerStream
}

type aPIPutTarServer struct {
	grpc.ServerStream
}

func (x *aPIPutTarServer) SendAndClose(m *types.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *aPIPutTarServer) Recv() (*PutTarRequest, error) {
	m := new(PutTarRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _API_GetTar_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetTarRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).GetTar(m, &aPIGetTarServer{stream})
}

type API_GetTarServer interface {
	Send(*types.BytesValue) error
	grpc.ServerStream
}

type aPIGetTarServer struct {
	grpc.ServerStream
}

func (x *aPIGetTarServer) Send(m *types.BytesValue) error {
	return x.ServerStream.SendMsg(m)
}

func _API_GetTarConditional_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(APIServer).GetTarConditional(&aPIGetTarConditionalServer{stream})
}

type API_GetTarConditionalServer interface {
	Send(*GetTarConditionalResponse) error
	Recv() (*GetTarConditionalRequest, error)
	grpc.ServerStream
}

type aPIGetTarConditionalServer struct {
	grpc.ServerStream
}

func (x *aPIGetTarConditionalServer) Send(m *GetTarConditionalResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *aPIGetTarConditionalServer) Recv() (*GetTarConditionalRequest, error) {
	m := new(GetTarConditionalRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _API_ListFileNS_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListFileNS(m, &aPIListFileNSServer{stream})
}

type API_ListFileNSServer interface {
	Send(*FileInfoNewStorage) error
	grpc.ServerStream
}

type aPIListFileNSServer struct {
	grpc.ServerStream
}

func (x *aPIListFileNSServer) Send(m *FileInfoNewStorage) error {
	return x.ServerStream.SendMsg(m)
}

var _API_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pfs.API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRepo",
			Handler:    _API_CreateRepo_Handler,
		},
		{
			MethodName: "InspectRepo",
			Handler:    _API_InspectRepo_Handler,
		},
		{
			MethodName: "ListRepo",
			Handler:    _API_ListRepo_Handler,
		},
		{
			MethodName: "DeleteRepo",
			Handler:    _API_DeleteRepo_Handler,
		},
		{
			MethodName: "StartCommit",
			Handler:    _API_StartCommit_Handler,
		},
		{
			MethodName: "FinishCommit",
			Handler:    _API_FinishCommit_Handler,
		},
		{
			MethodName: "InspectCommit",
			Handler:    _API_InspectCommit_Handler,
		},
		{
			MethodName: "ListCommit",
			Handler:    _API_ListCommit_Handler,
		},
		{
			MethodName: "DeleteCommit",
			Handler:    _API_DeleteCommit_Handler,
		},
		{
			MethodName: "BuildCommit",
			Handler:    _API_BuildCommit_Handler,
		},
		{
			MethodName: "CreateBranch",
			Handler:    _API_CreateBranch_Handler,
		},
		{
			MethodName: "InspectBranch",
			Handler:    _API_InspectBranch_Handler,
		},
		{
			MethodName: "ListBranch",
			Handler:    _API_ListBranch_Handler,
		},
		{
			MethodName: "DeleteBranch",
			Handler:    _API_DeleteBranch_Handler,
		},
		{
			MethodName: "CopyFile",
			Handler:    _API_CopyFile_Handler,
		},
		{
			MethodName: "InspectFile",
			Handler:    _API_InspectFile_Handler,
		},
		{
			MethodName: "ListFile",
			Handler:    _API_ListFile_Handler,
		},
		{
			MethodName: "GlobFile",
			Handler:    _API_GlobFile_Handler,
		},
		{
			MethodName: "DiffFile",
			Handler:    _API_DiffFile_Handler,
		},
		{
			MethodName: "DeleteFile",
			Handler:    _API_DeleteFile_Handler,
		},
		{
			MethodName: "DeleteAll",
			Handler:    _API_DeleteAll_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListCommitStream",
			Handler:       _API_ListCommitStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FlushCommit",
			Handler:       _API_FlushCommit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeCommit",
			Handler:       _API_SubscribeCommit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PutFile",
			Handler:       _API_PutFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetFile",
			Handler:       _API_GetFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListFileStream",
			Handler:       _API_ListFileStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WalkFile",
			Handler:       _API_WalkFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GlobFileStream",
			Handler:       _API_GlobFileStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Fsck",
			Handler:       _API_Fsck_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PutTar",
			Handler:       _API_PutTar_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetTar",
			Handler:       _API_GetTar_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetTarConditional",
			Handler:       _API_GetTarConditional_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ListFileNS",
			Handler:       _API_ListFileNS_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "client/pfs/pfs.proto",
}

// ObjectAPIClient is the client API for ObjectAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ObjectAPIClient interface {
	PutObject(ctx context.Context, opts ...grpc.CallOption) (ObjectAPI_PutObjectClient, error)
	PutObjectSplit(ctx context.Context, opts ...grpc.CallOption) (ObjectAPI_PutObjectSplitClient, error)
	PutObjects(ctx context.Context, opts ...grpc.CallOption) (ObjectAPI_PutObjectsClient, error)
	CreateObject(ctx context.Context, in *CreateObjectRequest, opts ...grpc.CallOption) (*types.Empty, error)
	GetObject(ctx context.Context, in *Object, opts ...grpc.CallOption) (ObjectAPI_GetObjectClient, error)
	GetObjects(ctx context.Context, in *GetObjectsRequest, opts ...grpc.CallOption) (ObjectAPI_GetObjectsClient, error)
	PutBlock(ctx context.Context, opts ...grpc.CallOption) (ObjectAPI_PutBlockClient, error)
	GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (ObjectAPI_GetBlockClient, error)
	GetBlocks(ctx context.Context, in *GetBlocksRequest, opts ...grpc.CallOption) (ObjectAPI_GetBlocksClient, error)
	ListBlock(ctx context.Context, in *ListBlockRequest, opts ...grpc.CallOption) (ObjectAPI_ListBlockClient, error)
	TagObject(ctx context.Context, in *TagObjectRequest, opts ...grpc.CallOption) (*types.Empty, error)
	InspectObject(ctx context.Context, in *Object, opts ...grpc.CallOption) (*ObjectInfo, error)
	// CheckObject checks if an object exists in the blob store without
	// actually reading the object.
	CheckObject(ctx context.Context, in *CheckObjectRequest, opts ...grpc.CallOption) (*CheckObjectResponse, error)
	ListObjects(ctx context.Context, in *ListObjectsRequest, opts ...grpc.CallOption) (ObjectAPI_ListObjectsClient, error)
	DeleteObjects(ctx context.Context, in *DeleteObjectsRequest, opts ...grpc.CallOption) (*DeleteObjectsResponse, error)
	GetTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (ObjectAPI_GetTagClient, error)
	InspectTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*ObjectInfo, error)
	ListTags(ctx context.Context, in *ListTagsRequest, opts ...grpc.CallOption) (ObjectAPI_ListTagsClient, error)
	DeleteTags(ctx context.Context, in *DeleteTagsRequest, opts ...grpc.CallOption) (*DeleteTagsResponse, error)
	Compact(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*types.Empty, error)
	// PutObjDirect puts an obj directly into object store, bypassing the content
	// addressing layer.
	PutObjDirect(ctx context.Context, opts ...grpc.CallOption) (ObjectAPI_PutObjDirectClient, error)
	// GetObjDirect gets an obj directly out of object store, bypassing the
	// content addressing layer.
	GetObjDirect(ctx context.Context, in *GetObjDirectRequest, opts ...grpc.CallOption) (ObjectAPI_GetObjDirectClient, error)
}

type objectAPIClient struct {
	cc *grpc.ClientConn
}

func NewObjectAPIClient(cc *grpc.ClientConn) ObjectAPIClient {
	return &objectAPIClient{cc}
}

func (c *objectAPIClient) PutObject(ctx context.Context, opts ...grpc.CallOption) (ObjectAPI_PutObjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ObjectAPI_serviceDesc.Streams[0], "/pfs.ObjectAPI/PutObject", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIPutObjectClient{stream}
	return x, nil
}

type ObjectAPI_PutObjectClient interface {
	Send(*PutObjectRequest) error
	CloseAndRecv() (*Object, error)
	grpc.ClientStream
}

type objectAPIPutObjectClient struct {
	grpc.ClientStream
}

func (x *objectAPIPutObjectClient) Send(m *PutObjectRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *objectAPIPutObjectClient) CloseAndRecv() (*Object, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Object)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) PutObjectSplit(ctx context.Context, opts ...grpc.CallOption) (ObjectAPI_PutObjectSplitClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ObjectAPI_serviceDesc.Streams[1], "/pfs.ObjectAPI/PutObjectSplit", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIPutObjectSplitClient{stream}
	return x, nil
}

type ObjectAPI_PutObjectSplitClient interface {
	Send(*PutObjectRequest) error
	CloseAndRecv() (*Objects, error)
	grpc.ClientStream
}

type objectAPIPutObjectSplitClient struct {
	grpc.ClientStream
}

func (x *objectAPIPutObjectSplitClient) Send(m *PutObjectRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *objectAPIPutObjectSplitClient) CloseAndRecv() (*Objects, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Objects)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) PutObjects(ctx context.Context, opts ...grpc.CallOption) (ObjectAPI_PutObjectsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ObjectAPI_serviceDesc.Streams[2], "/pfs.ObjectAPI/PutObjects", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIPutObjectsClient{stream}
	return x, nil
}

type ObjectAPI_PutObjectsClient interface {
	Send(*PutObjectRequest) error
	CloseAndRecv() (*types.Empty, error)
	grpc.ClientStream
}

type objectAPIPutObjectsClient struct {
	grpc.ClientStream
}

func (x *objectAPIPutObjectsClient) Send(m *PutObjectRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *objectAPIPutObjectsClient) CloseAndRecv() (*types.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(types.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) CreateObject(ctx context.Context, in *CreateObjectRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.ObjectAPI/CreateObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAPIClient) GetObject(ctx context.Context, in *Object, opts ...grpc.CallOption) (ObjectAPI_GetObjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ObjectAPI_serviceDesc.Streams[3], "/pfs.ObjectAPI/GetObject", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIGetObjectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectAPI_GetObjectClient interface {
	Recv() (*types.BytesValue, error)
	grpc.ClientStream
}

type objectAPIGetObjectClient struct {
	grpc.ClientStream
}

func (x *objectAPIGetObjectClient) Recv() (*types.BytesValue, error) {
	m := new(types.BytesValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) GetObjects(ctx context.Context, in *GetObjectsRequest, opts ...grpc.CallOption) (ObjectAPI_GetObjectsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ObjectAPI_serviceDesc.Streams[4], "/pfs.ObjectAPI/GetObjects", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIGetObjectsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectAPI_GetObjectsClient interface {
	Recv() (*types.BytesValue, error)
	grpc.ClientStream
}

type objectAPIGetObjectsClient struct {
	grpc.ClientStream
}

func (x *objectAPIGetObjectsClient) Recv() (*types.BytesValue, error) {
	m := new(types.BytesValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) PutBlock(ctx context.Context, opts ...grpc.CallOption) (ObjectAPI_PutBlockClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ObjectAPI_serviceDesc.Streams[5], "/pfs.ObjectAPI/PutBlock", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIPutBlockClient{stream}
	return x, nil
}

type ObjectAPI_PutBlockClient interface {
	Send(*PutBlockRequest) error
	CloseAndRecv() (*types.Empty, error)
	grpc.ClientStream
}

type objectAPIPutBlockClient struct {
	grpc.ClientStream
}

func (x *objectAPIPutBlockClient) Send(m *PutBlockRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *objectAPIPutBlockClient) CloseAndRecv() (*types.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(types.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (ObjectAPI_GetBlockClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ObjectAPI_serviceDesc.Streams[6], "/pfs.ObjectAPI/GetBlock", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIGetBlockClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectAPI_GetBlockClient interface {
	Recv() (*types.BytesValue, error)
	grpc.ClientStream
}

type objectAPIGetBlockClient struct {
	grpc.ClientStream
}

func (x *objectAPIGetBlockClient) Recv() (*types.BytesValue, error) {
	m := new(types.BytesValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) GetBlocks(ctx context.Context, in *GetBlocksRequest, opts ...grpc.CallOption) (ObjectAPI_GetBlocksClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ObjectAPI_serviceDesc.Streams[7], "/pfs.ObjectAPI/GetBlocks", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIGetBlocksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectAPI_GetBlocksClient interface {
	Recv() (*types.BytesValue, error)
	grpc.ClientStream
}

type objectAPIGetBlocksClient struct {
	grpc.ClientStream
}

func (x *objectAPIGetBlocksClient) Recv() (*types.BytesValue, error) {
	m := new(types.BytesValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) ListBlock(ctx context.Context, in *ListBlockRequest, opts ...grpc.CallOption) (ObjectAPI_ListBlockClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ObjectAPI_serviceDesc.Streams[8], "/pfs.ObjectAPI/ListBlock", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIListBlockClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectAPI_ListBlockClient interface {
	Recv() (*Block, error)
	grpc.ClientStream
}

type objectAPIListBlockClient struct {
	grpc.ClientStream
}

func (x *objectAPIListBlockClient) Recv() (*Block, error) {
	m := new(Block)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) TagObject(ctx context.Context, in *TagObjectRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.ObjectAPI/TagObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAPIClient) InspectObject(ctx context.Context, in *Object, opts ...grpc.CallOption) (*ObjectInfo, error) {
	out := new(ObjectInfo)
	err := c.cc.Invoke(ctx, "/pfs.ObjectAPI/InspectObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAPIClient) CheckObject(ctx context.Context, in *CheckObjectRequest, opts ...grpc.CallOption) (*CheckObjectResponse, error) {
	out := new(CheckObjectResponse)
	err := c.cc.Invoke(ctx, "/pfs.ObjectAPI/CheckObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAPIClient) ListObjects(ctx context.Context, in *ListObjectsRequest, opts ...grpc.CallOption) (ObjectAPI_ListObjectsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ObjectAPI_serviceDesc.Streams[9], "/pfs.ObjectAPI/ListObjects", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIListObjectsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectAPI_ListObjectsClient interface {
	Recv() (*ObjectInfo, error)
	grpc.ClientStream
}

type objectAPIListObjectsClient struct {
	grpc.ClientStream
}

func (x *objectAPIListObjectsClient) Recv() (*ObjectInfo, error) {
	m := new(ObjectInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) DeleteObjects(ctx context.Context, in *DeleteObjectsRequest, opts ...grpc.CallOption) (*DeleteObjectsResponse, error) {
	out := new(DeleteObjectsResponse)
	err := c.cc.Invoke(ctx, "/pfs.ObjectAPI/DeleteObjects", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAPIClient) GetTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (ObjectAPI_GetTagClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ObjectAPI_serviceDesc.Streams[10], "/pfs.ObjectAPI/GetTag", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIGetTagClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectAPI_GetTagClient interface {
	Recv() (*types.BytesValue, error)
	grpc.ClientStream
}

type objectAPIGetTagClient struct {
	grpc.ClientStream
}

func (x *objectAPIGetTagClient) Recv() (*types.BytesValue, error) {
	m := new(types.BytesValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) InspectTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*ObjectInfo, error) {
	out := new(ObjectInfo)
	err := c.cc.Invoke(ctx, "/pfs.ObjectAPI/InspectTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAPIClient) ListTags(ctx context.Context, in *ListTagsRequest, opts ...grpc.CallOption) (ObjectAPI_ListTagsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ObjectAPI_serviceDesc.Streams[11], "/pfs.ObjectAPI/ListTags", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIListTagsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectAPI_ListTagsClient interface {
	Recv() (*ListTagsResponse, error)
	grpc.ClientStream
}

type objectAPIListTagsClient struct {
	grpc.ClientStream
}

func (x *objectAPIListTagsClient) Recv() (*ListTagsResponse, error) {
	m := new(ListTagsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) DeleteTags(ctx context.Context, in *DeleteTagsRequest, opts ...grpc.CallOption) (*DeleteTagsResponse, error) {
	out := new(DeleteTagsResponse)
	err := c.cc.Invoke(ctx, "/pfs.ObjectAPI/DeleteTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAPIClient) Compact(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.ObjectAPI/Compact", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAPIClient) PutObjDirect(ctx context.Context, opts ...grpc.CallOption) (ObjectAPI_PutObjDirectClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ObjectAPI_serviceDesc.Streams[12], "/pfs.ObjectAPI/PutObjDirect", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIPutObjDirectClient{stream}
	return x, nil
}

type ObjectAPI_PutObjDirectClient interface {
	Send(*PutObjDirectRequest) error
	CloseAndRecv() (*types.Empty, error)
	grpc.ClientStream
}

type objectAPIPutObjDirectClient struct {
	grpc.ClientStream
}

func (x *objectAPIPutObjDirectClient) Send(m *PutObjDirectRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *objectAPIPutObjDirectClient) CloseAndRecv() (*types.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(types.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) GetObjDirect(ctx context.Context, in *GetObjDirectRequest, opts ...grpc.CallOption) (ObjectAPI_GetObjDirectClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ObjectAPI_serviceDesc.Streams[13], "/pfs.ObjectAPI/GetObjDirect", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIGetObjDirectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectAPI_GetObjDirectClient interface {
	Recv() (*types.BytesValue, error)
	grpc.ClientStream
}

type objectAPIGetObjDirectClient struct {
	grpc.ClientStream
}

func (x *objectAPIGetObjDirectClient) Recv() (*types.BytesValue, error) {
	m := new(types.BytesValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ObjectAPIServer is the server API for ObjectAPI service.
type ObjectAPIServer interface {
	PutObject(ObjectAPI_PutObjectServer) error
	PutObjectSplit(ObjectAPI_PutObjectSplitServer) error
	PutObjects(ObjectAPI_PutObjectsServer) error
	CreateObject(context.Context, *CreateObjectRequest) (*types.Empty, error)
	GetObject(*Object, ObjectAPI_GetObjectServer) error
	GetObjects(*GetObjectsRequest, ObjectAPI_GetObjectsServer) error
	PutBlock(ObjectAPI_PutBlockServer) error
	GetBlock(*GetBlockRequest, ObjectAPI_GetBlockServer) error
	GetBlocks(*GetBlocksRequest, ObjectAPI_GetBlocksServer) error
	ListBlock(*ListBlockRequest, ObjectAPI_ListBlockServer) error
	TagObject(context.Context, *TagObjectRequest) (*types.Empty, error)
	InspectObject(context.Context, *Object) (*ObjectInfo, error)
	// CheckObject checks if an object exists in the blob store without
	// actually reading the object.
	CheckObject(context.Context, *CheckObjectRequest) (*CheckObjectResponse, error)
	ListObjects(*ListObjectsRequest, ObjectAPI_ListObjectsServer) error
	DeleteObjects(context.Context, *DeleteObjectsRequest) (*DeleteObjectsResponse, error)
	GetTag(*Tag, ObjectAPI_GetTagServer) error
	InspectTag(context.Context, *Tag) (*ObjectInfo, error)
	ListTags(*ListTagsRequest, ObjectAPI_ListTagsServer) error
	DeleteTags(context.Context, *DeleteTagsRequest) (*DeleteTagsResponse, error)
	Compact(context.Context, *types.Empty) (*types.Empty, error)
	// PutObjDirect puts an obj directly into object store, bypassing the content
	// addressing layer.
	PutObjDirect(ObjectAPI_PutObjDirectServer) error
	// GetObjDirect gets an obj directly out of object store, bypassing the
	// content addressing layer.
	GetObjDirect(*GetObjDirectRequest, ObjectAPI_GetObjDirectServer) error
}

// UnimplementedObjectAPIServer can be embedded to have forward compatible implementations.
type UnimplementedObjectAPIServer struct {
}

func (*UnimplementedObjectAPIServer) PutObject(srv ObjectAPI_PutObjectServer) error {
	return status.Errorf(codes.Unimplemented, "method PutObject not implemented")
}
func (*UnimplementedObjectAPIServer) PutObjectSplit(srv ObjectAPI_PutObjectSplitServer) error {
	return status.Errorf(codes.Unimplemented, "method PutObjectSplit not implemented")
}
func (*UnimplementedObjectAPIServer) PutObjects(srv ObjectAPI_PutObjectsServer) error {
	return status.Errorf(codes.Unimplemented, "method PutObjects not implemented")
}
func (*UnimplementedObjectAPIServer) CreateObject(ctx context.Context, req *CreateObjectRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateObject not implemented")
}
func (*UnimplementedObjectAPIServer) GetObject(req *Object, srv ObjectAPI_GetObjectServer) error {
	return status.Errorf(codes.Unimplemented, "method GetObject not implemented")
}
func (*UnimplementedObjectAPIServer) GetObjects(req *GetObjectsRequest, srv ObjectAPI_GetObjectsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetObjects not implemented")
}
func (*UnimplementedObjectAPIServer) PutBlock(srv ObjectAPI_PutBlockServer) error {
	return status.Errorf(codes.Unimplemented, "method PutBlock not implemented")
}
func (*UnimplementedObjectAPIServer) GetBlock(req *GetBlockRequest, srv ObjectAPI_GetBlockServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBlock not implemented")
}
func (*UnimplementedObjectAPIServer) GetBlocks(req *GetBlocksRequest, srv ObjectAPI_GetBlocksServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBlocks not implemented")
}
func (*UnimplementedObjectAPIServer) ListBlock(req *ListBlockRequest, srv ObjectAPI_ListBlockServer) error {
	return status.Errorf(codes.Unimplemented, "method ListBlock not implemented")
}
func (*UnimplementedObjectAPIServer) TagObject(ctx context.Context, req *TagObjectRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TagObject not implemented")
}
func (*UnimplementedObjectAPIServer) InspectObject(ctx context.Context, req *Object) (*ObjectInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectObject not implemented")
}
func (*UnimplementedObjectAPIServer) CheckObject(ctx context.Context, req *CheckObjectRequest) (*CheckObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckObject not implemented")
}
func (*UnimplementedObjectAPIServer) ListObjects(req *ListObjectsRequest, srv ObjectAPI_ListObjectsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListObjects not implemented")
}
func (*UnimplementedObjectAPIServer) DeleteObjects(ctx context.Context, req *DeleteObjectsRequest) (*DeleteObjectsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteObjects not implemented")
}
func (*UnimplementedObjectAPIServer) GetTag(req *Tag, srv ObjectAPI_GetTagServer) error {
	return status.Errorf(codes.Unimplemented, "method GetTag not implemented")
}
func (*UnimplementedObjectAPIServer) InspectTag(ctx context.Context, req *Tag) (*ObjectInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectTag not implemented")
}
func (*UnimplementedObjectAPIServer) ListTags(req *ListTagsRequest, srv ObjectAPI_ListTagsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListTags not implemented")
}
func (*UnimplementedObjectAPIServer) DeleteTags(ctx context.Context, req *DeleteTagsRequest) (*DeleteTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTags not implemented")
}
func (*UnimplementedObjectAPIServer) Compact(ctx context.Context, req *types.Empty) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Compact not implemented")
}
func (*UnimplementedObjectAPIServer) PutObjDirect(srv ObjectAPI_PutObjDirectServer) error {
	return status.Errorf(codes.Unimplemented, "method PutObjDirect not implemented")
}
func (*UnimplementedObjectAPIServer) GetObjDirect(req *GetObjDirectRequest, srv ObjectAPI_GetObjDirectServer) error {
	return status.Errorf(codes.Unimplemented, "method GetObjDirect not implemented")
}

func RegisterObjectAPIServer(s *grpc.Server, srv ObjectAPIServer) {
	s.RegisterService(&_ObjectAPI_serviceDesc, srv)
}

func _ObjectAPI_PutObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ObjectAPIServer).PutObject(&objectAPIPutObjectServer{stream})
}

type ObjectAPI_PutObjectServer interface {
	SendAndClose(*Object) error
	Recv() (*PutObjectRequest, error)
	grpc.ServerStream
}

type objectAPIPutObjectServer struct {
	grpc.ServerStream
}

func (x *objectAPIPutObjectServer) SendAndClose(m *Object) error {
	return x.ServerStream.SendMsg(m)
}

func (x *objectAPIPutObjectServer) Recv() (*PutObjectRequest, error) {
	m := new(PutObjectRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ObjectAPI_PutObjectSplit_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ObjectAPIServer).PutObjectSplit(&objectAPIPutObjectSplitServer{stream})
}

type ObjectAPI_PutObjectSplitServer interface {
	SendAndClose(*Objects) error
	Recv() (*PutObjectRequest, error)
	grpc.ServerStream
}

type objectAPIPutObjectSplitServer struct {
	grpc.ServerStream
}

func (x *objectAPIPutObjectSplitServer) SendAndClose(m *Objects) error {
	return x.ServerStream.SendMsg(m)
}

func (x *objectAPIPutObjectSplitServer) Recv() (*PutObjectRequest, error) {
	m := new(PutObjectRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ObjectAPI_PutObjects_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ObjectAPIServer).PutObjects(&objectAPIPutObjectsServer{stream})
}

type ObjectAPI_PutObjectsServer interface {
	SendAndClose(*types.Empty) error
	Recv() (*PutObjectRequest, error)
	grpc.ServerStream
}

type objectAPIPutObjectsServer struct {
	grpc.ServerStream
}

func (x *objectAPIPutObjectsServer) SendAndClose(m *types.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *objectAPIPutObjectsServer) Recv() (*PutObjectRequest, error) {
	m := new(PutObjectRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ObjectAPI_CreateObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAPIServer).CreateObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.ObjectAPI/CreateObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAPIServer).CreateObject(ctx, req.(*CreateObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAPI_GetObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Object)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectAPIServer).GetObject(m, &objectAPIGetObjectServer{stream})
}

type ObjectAPI_GetObjectServer interface {
	Send(*types.BytesValue) error
	grpc.ServerStream
}

type objectAPIGetObjectServer struct {
	grpc.ServerStream
}

func (x *objectAPIGetObjectServer) Send(m *types.BytesValue) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectAPI_GetObjects_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetObjectsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectAPIServer).GetObjects(m, &objectAPIGetObjectsServer{stream})
}

type ObjectAPI_GetObjectsServer interface {
	Send(*types.BytesValue) error
	grpc.ServerStream
}

type objectAPIGetObjectsServer struct {
	grpc.ServerStream
}

func (x *objectAPIGetObjectsServer) Send(m *types.BytesValue) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectAPI_PutBlock_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ObjectAPIServer).PutBlock(&objectAPIPutBlockServer{stream})
}

type ObjectAPI_PutBlockServer interface {
	SendAndClose(*types.Empty) error
	Recv() (*PutBlockRequest, error)
	grpc.ServerStream
}

type objectAPIPutBlockServer struct {
	grpc.ServerStream
}

func (x *objectAPIPutBlockServer) SendAndClose(m *types.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *objectAPIPutBlockServer) Recv() (*PutBlockRequest, error) {
	m := new(PutBlockRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ObjectAPI_GetBlock_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetBlockRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectAPIServer).GetBlock(m, &objectAPIGetBlockServer{stream})
}

type ObjectAPI_GetBlockServer interface {
	Send(*types.BytesValue) error
	grpc.ServerStream
}

type objectAPIGetBlockServer struct {
	grpc.ServerStream
}

func (x *objectAPIGetBlockServer) Send(m *types.BytesValue) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectAPI_GetBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetBlocksRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectAPIServer).GetBlocks(m, &objectAPIGetBlocksServer{stream})
}

type ObjectAPI_GetBlocksServer interface {
	Send(*types.BytesValue) error
	grpc.ServerStream
}

type objectAPIGetBlocksServer struct {
	grpc.ServerStream
}

func (x *objectAPIGetBlocksServer) Send(m *types.BytesValue) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectAPI_ListBlock_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListBlockRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectAPIServer).ListBlock(m, &objectAPIListBlockServer{stream})
}

type ObjectAPI_ListBlockServer interface {
	Send(*Block) error
	grpc.ServerStream
}

type objectAPIListBlockServer struct {
	grpc.ServerStream
}

func (x *objectAPIListBlockServer) Send(m *Block) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectAPI_TagObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAPIServer).TagObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.ObjectAPI/TagObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAPIServer).TagObject(ctx, req.(*TagObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAPI_InspectObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Object)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAPIServer).InspectObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.ObjectAPI/InspectObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAPIServer).InspectObject(ctx, req.(*Object))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAPI_CheckObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAPIServer).CheckObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.ObjectAPI/CheckObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAPIServer).CheckObject(ctx, req.(*CheckObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAPI_ListObjects_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListObjectsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectAPIServer).ListObjects(m, &objectAPIListObjectsServer{stream})
}

type ObjectAPI_ListObjectsServer interface {
	Send(*ObjectInfo) error
	grpc.ServerStream
}

type objectAPIListObjectsServer struct {
	grpc.ServerStream
}

func (x *objectAPIListObjectsServer) Send(m *ObjectInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectAPI_DeleteObjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteObjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAPIServer).DeleteObjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.ObjectAPI/DeleteObjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAPIServer).DeleteObjects(ctx, req.(*DeleteObjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAPI_GetTag_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Tag)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectAPIServer).GetTag(m, &objectAPIGetTagServer{stream})
}

type ObjectAPI_GetTagServer interface {
	Send(*types.BytesValue) error
	grpc.ServerStream
}

type objectAPIGetTagServer struct {
	grpc.ServerStream
}

func (x *objectAPIGetTagServer) Send(m *types.BytesValue) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectAPI_InspectTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAPIServer).InspectTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.ObjectAPI/InspectTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAPIServer).InspectTag(ctx, req.(*Tag))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAPI_ListTags_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListTagsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectAPIServer).ListTags(m, &objectAPIListTagsServer{stream})
}

type ObjectAPI_ListTagsServer interface {
	Send(*ListTagsResponse) error
	grpc.ServerStream
}

type objectAPIListTagsServer struct {
	grpc.ServerStream
}

func (x *objectAPIListTagsServer) Send(m *ListTagsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectAPI_DeleteTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAPIServer).DeleteTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.ObjectAPI/DeleteTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAPIServer).DeleteTags(ctx, req.(*DeleteTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAPI_Compact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAPIServer).Compact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.ObjectAPI/Compact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAPIServer).Compact(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAPI_PutObjDirect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ObjectAPIServer).PutObjDirect(&objectAPIPutObjDirectServer{stream})
}

type ObjectAPI_PutObjDirectServer interface {
	SendAndClose(*types.Empty) error
	Recv() (*PutObjDirectRequest, error)
	grpc.ServerStream
}

type objectAPIPutObjDirectServer struct {
	grpc.ServerStream
}

func (x *objectAPIPutObjDirectServer) SendAndClose(m *types.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *objectAPIPutObjDirectServer) Recv() (*PutObjDirectRequest, error) {
	m := new(PutObjDirectRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ObjectAPI_GetObjDirect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetObjDirectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectAPIServer).GetObjDirect(m, &objectAPIGetObjDirectServer{stream})
}

type ObjectAPI_GetObjDirectServer interface {
	Send(*types.BytesValue) error
	grpc.ServerStream
}

type objectAPIGetObjDirectServer struct {
	grpc.ServerStream
}

func (x *objectAPIGetObjDirectServer) Send(m *types.BytesValue) error {
	return x.ServerStream.SendMsg(m)
}

var _ObjectAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pfs.ObjectAPI",
	HandlerType: (*ObjectAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateObject",
			Handler:    _ObjectAPI_CreateObject_Handler,
		},
		{
			MethodName: "TagObject",
			Handler:    _ObjectAPI_TagObject_Handler,
		},
		{
			MethodName: "InspectObject",
			Handler:    _ObjectAPI_InspectObject_Handler,
		},
		{
			MethodName: "CheckObject",
			Handler:    _ObjectAPI_CheckObject_Handler,
		},
		{
			MethodName: "DeleteObjects",
			Handler:    _ObjectAPI_DeleteObjects_Handler,
		},
		{
			MethodName: "InspectTag",
			Handler:    _ObjectAPI_InspectTag_Handler,
		},
		{
			MethodName: "DeleteTags",
			Handler:    _ObjectAPI_DeleteTags_Handler,
		},
		{
			MethodName: "Compact",
			Handler:    _ObjectAPI_Compact_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PutObject",
			Handler:       _ObjectAPI_PutObject_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "PutObjectSplit",
			Handler:       _ObjectAPI_PutObjectSplit_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "PutObjects",
			Handler:       _ObjectAPI_PutObjects_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetObject",
			Handler:       _ObjectAPI_GetObject_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetObjects",
			Handler:       _ObjectAPI_GetObjects_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PutBlock",
			Handler:       _ObjectAPI_PutBlock_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetBlock",
			Handler:       _ObjectAPI_GetBlock_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBlocks",
			Handler:       _ObjectAPI_GetBlocks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListBlock",
			Handler:       _ObjectAPI_ListBlock_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListObjects",
			Handler:       _ObjectAPI_ListObjects_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetTag",
			Handler:       _ObjectAPI_GetTag_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListTags",
			Handler:       _ObjectAPI_ListTags_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PutObjDirect",
			Handler:       _ObjectAPI_PutObjDirect_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetObjDirect",
			Handler:       _ObjectAPI_GetObjDirect_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "client/pfs/pfs.proto",
}

func (m *Repo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Repo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Repo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Branch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Branch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Branch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BranchInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BranchInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BranchInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DirectProvenance) > 0 {
		for iNdEx := len(m.DirectProvenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DirectProvenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Subvenance) > 0 {
		for iNdEx := len(m.Subvenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subvenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Provenance) > 0 {
		for iNdEx := len(m.Provenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Provenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Head != nil {
		{
			size, err := m.Head.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BranchInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BranchInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BranchInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BranchInfo) > 0 {
		for iNdEx := len(m.BranchInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BranchInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Block) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Object) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RepoInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepoInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RepoInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Branches) > 0 {
		for iNdEx := len(m.Branches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Branches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.AuthInfo != nil {
		{
			size, err := m.AuthInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.Created != nil {
		{
			size, err := m.Created.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RepoAuthInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepoAuthInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RepoAuthInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AccessLevel != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.AccessLevel))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommitOrigin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitOrigin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitOrigin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Kind != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Commit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Commit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Upper != nil {
		{
			size, err := m.Upper.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Lower != nil {
		{
			size, err := m.Lower.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitProvenance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitProvenance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitProvenance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubvenantCommitsTotal != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SubvenantCommitsTotal))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.SubvenantCommitsFailure != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SubvenantCommitsFailure))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.SubvenantCommitsSuccess != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SubvenantCommitsSuccess))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Origin != nil {
		{
			size, err := m.Origin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Provenance) > 0 {
		for iNdEx := len(m.Provenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Provenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Datums != nil {
		{
			size, err := m.Datums.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.Trees) > 0 {
		for iNdEx := len(m.Trees) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Trees[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.ReadyProvenance != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.ReadyProvenance))
		i--
		dAtA[i] = 0x60
	}
	if len(m.ChildCommits) > 0 {
		for iNdEx := len(m.ChildCommits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChildCommits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Subvenance) > 0 {
		for iNdEx := len(m.Subvenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subvenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x42
	}
	if m.Tree != nil {
		{
			size, err := m.Tree.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.Finished != nil {
		{
			size, err := m.Finished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Started != nil {
		{
			size, err := m.Started.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ParentCommit != nil {
		{
			size, err := m.ParentCommit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Committed != nil {
		{
			size, err := m.Committed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.BlockRefs) > 0 {
		for iNdEx := len(m.BlockRefs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BlockRefs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Objects) > 0 {
		for iNdEx := len(m.Objects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Objects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Children[iNdEx])
			copy(dAtA[i:], m.Children[iNdEx])
			i = encodeVarintPfs(dAtA, i, uint64(len(m.Children[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.FileType != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.FileType))
		i--
		dAtA[i] = 0x10
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ByteRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ByteRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ByteRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Upper != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Upper))
		i--
		dAtA[i] = 0x10
	}
	if m.Lower != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Lower))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockRef != nil {
		{
			size, err := m.BlockRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Object != nil {
		{
			size, err := m.Object.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Compaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Compaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Compaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InputPrefixes) > 0 {
		for iNdEx := len(m.InputPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InputPrefixes[iNdEx])
			copy(dAtA[i:], m.InputPrefixes[iNdEx])
			i = encodeVarintPfs(dAtA, i, uint64(len(m.InputPrefixes[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *Shard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Shard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OutputPath) > 0 {
		i -= len(m.OutputPath)
		copy(dAtA[i:], m.OutputPath)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.OutputPath)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Compaction != nil {
		{
			size, err := m.Compaction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PathRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Upper) > 0 {
		i -= len(m.Upper)
		copy(dAtA[i:], m.Upper)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Upper)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Lower) > 0 {
		i -= len(m.Lower)
		copy(dAtA[i:], m.Lower)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Lower)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateRepoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateRepoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateRepoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Update {
		i--
		if m.Update {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectRepoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectRepoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectRepoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListRepoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRepoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRepoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ListRepoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRepoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRepoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RepoInfo) > 0 {
		for iNdEx := len(m.RepoInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RepoInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteRepoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRepoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRepoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.All {
		i--
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Provenance) > 0 {
		for iNdEx := len(m.Provenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Provenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Branch) > 0 {
		i -= len(m.Branch)
		copy(dAtA[i:], m.Branch)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Branch)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Parent != nil {
		{
			size, err := m.Parent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BuildCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Finished != nil {
		{
			size, err := m.Finished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Started != nil {
		{
			size, err := m.Started.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x48
	}
	if m.Datums != nil {
		{
			size, err := m.Datums.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Trees) > 0 {
		for iNdEx := len(m.Trees) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Trees[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Provenance) > 0 {
		for iNdEx := len(m.Provenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Provenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Branch) > 0 {
		i -= len(m.Branch)
		copy(dAtA[i:], m.Branch)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Branch)))
		i--
		dAtA[i] = 0x22
	}
	if m.Tree != nil {
		{
			size, err := m.Tree.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Parent != nil {
		{
			size, err := m.Parent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FinishCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinishCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Datums != nil {
		{
			size, err := m.Datums.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Trees) > 0 {
		for iNdEx := len(m.Trees) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Trees[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Empty {
		i--
		if m.Empty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Tree != nil {
		{
			size, err := m.Tree.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockState != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.BlockState))
		i--
		dAtA[i] = 0x10
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reverse {
		i--
		if m.Reverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Number != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x20
	}
	if m.To != nil {
		{
			size, err := m.To.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CommitInfo) > 0 {
		for iNdEx := len(m.CommitInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CommitInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateBranchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateBranchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateBranchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Provenance) > 0 {
		for iNdEx := len(m.Provenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Provenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SBranch) > 0 {
		i -= len(m.SBranch)
		copy(dAtA[i:], m.SBranch)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.SBranch)))
		i--
		dAtA[i] = 0x12
	}
	if m.Head != nil {
		{
			size, err := m.Head.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectBranchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectBranchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectBranchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListBranchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListBranchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListBranchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reverse {
		i--
		if m.Reverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteBranchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteBranchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteBranchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlushCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlushCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlushCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ToRepos) > 0 {
		for iNdEx := len(m.ToRepos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ToRepos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Commits) > 0 {
		for iNdEx := len(m.Commits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Prov != nil {
		{
			size, err := m.Prov.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.State != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Branch) > 0 {
		i -= len(m.Branch)
		copy(dAtA[i:], m.Branch)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Branch)))
		i--
		dAtA[i] = 0x12
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.OffsetBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.OffsetBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OverwriteIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OverwriteIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OverwriteIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Index != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PutFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HeaderRecords != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.HeaderRecords))
		i--
		dAtA[i] = 0x58
	}
	if m.OverwriteIndex != nil {
		{
			size, err := m.OverwriteIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.TargetFileBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.TargetFileBytes))
		i--
		dAtA[i] = 0x48
	}
	if m.TargetFileDatums != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.TargetFileDatums))
		i--
		dAtA[i] = 0x40
	}
	if m.Delimiter != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Delimiter))
		i--
		dAtA[i] = 0x38
	}
	if m.Recursive {
		i--
		if m.Recursive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PutFileRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutFileRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutFileRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockRef != nil {
		{
			size, err := m.BlockRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OverwriteIndex != nil {
		{
			size, err := m.OverwriteIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ObjectHash) > 0 {
		i -= len(m.ObjectHash)
		copy(dAtA[i:], m.ObjectHash)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.ObjectHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PutFileRecords) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutFileRecords) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutFileRecords) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Footer != nil {
		{
			size, err := m.Footer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Tombstone {
		i--
		if m.Tombstone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Split {
		i--
		if m.Split {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CopyFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CopyFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CopyFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Overwrite {
		i--
		if m.Overwrite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Dst != nil {
		{
			size, err := m.Dst.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Src != nil {
		{
			size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.History != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.History))
		i--
		dAtA[i] = 0x18
	}
	if m.Full {
		i--
		if m.Full {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WalkFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalkFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalkFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pattern) > 0 {
		i -= len(m.Pattern)
		copy(dAtA[i:], m.Pattern)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Pattern)))
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileInfo) > 0 {
		for iNdEx := len(m.FileInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FileInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DiffFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiffFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiffFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Shallow {
		i--
		if m.Shallow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.OldFile != nil {
		{
			size, err := m.OldFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NewFile != nil {
		{
			size, err := m.NewFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiffFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiffFileResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiffFileResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OldFiles) > 0 {
		for iNdEx := len(m.OldFiles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OldFiles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.NewFiles) > 0 {
		for iNdEx := len(m.NewFiles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NewFiles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FsckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsckRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FsckRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Fix {
		i--
		if m.Fix {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FsckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FsckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Fix) > 0 {
		i -= len(m.Fix)
		copy(dAtA[i:], m.Fix)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Fix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileInfoNewStorage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileInfoNewStorage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileInfoNewStorage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PutTarRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutTarRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutTarRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTarRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTarRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTarRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTarConditionalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTarConditionalRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTarConditionalRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Skip {
		i--
		if m.Skip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTarConditionalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTarConditionalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTarConditionalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Eof {
		i--
		if m.Eof {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.FileInfo != nil {
		{
			size, err := m.FileInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PutObjectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutObjectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutObjectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateObjectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateObjectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateObjectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockRef != nil {
		{
			size, err := m.BlockRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Object != nil {
		{
			size, err := m.Object.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetObjectsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetObjectsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetObjectsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalSize != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.TotalSize))
		i--
		dAtA[i] = 0x20
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.OffsetBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.OffsetBytes))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Objects) > 0 {
		for iNdEx := len(m.Objects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Objects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PutBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBlocksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlocksRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlocksRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalSize != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.TotalSize))
		i--
		dAtA[i] = 0x20
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.OffsetBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.OffsetBytes))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BlockRefs) > 0 {
		for iNdEx := len(m.BlockRefs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BlockRefs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TagObjectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagObjectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagObjectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Object != nil {
		{
			size, err := m.Object.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListObjectsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListObjectsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListObjectsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ListTagsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTagsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTagsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IncludeObject {
		i--
		if m.IncludeObject {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListTagsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTagsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTagsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Object != nil {
		{
			size, err := m.Object.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Tag != nil {
		{
			size, err := m.Tag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteObjectsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteObjectsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteObjectsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Objects) > 0 {
		for iNdEx := len(m.Objects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Objects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteObjectsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteObjectsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteObjectsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteTagsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteTagsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteTagsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteTagsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteTagsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteTagsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *CheckObjectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckObjectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckObjectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Object != nil {
		{
			size, err := m.Object.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckObjectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckObjectResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckObjectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Exists {
		i--
		if m.Exists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Objects) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Objects) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Objects) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Objects) > 0 {
		for iNdEx := len(m.Objects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Objects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PutObjDirectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutObjDirectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutObjDirectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Obj) > 0 {
		i -= len(m.Obj)
		copy(dAtA[i:], m.Obj)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Obj)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetObjDirectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetObjDirectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetObjDirectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Obj) > 0 {
		i -= len(m.Obj)
		copy(dAtA[i:], m.Obj)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Obj)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPfs(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPfs(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPfs(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Objects) > 0 {
		for k := range m.Objects {
			v := m.Objects[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPfs(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPfs(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPfs(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintPfs(dAtA []byte, offset int, v uint64) int {
	offset -= sovPfs(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Repo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Branch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BranchInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Head != nil {
		l = m.Head.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Subvenance) > 0 {
		for _, e := range m.Subvenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if len(m.DirectProvenance) > 0 {
		for _, e := range m.DirectProvenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BranchInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BranchInfo) > 0 {
		for _, e := range m.BranchInfo {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Object) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepoInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Created != nil {
		l = m.Created.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.AuthInfo != nil {
		l = m.AuthInfo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Branches) > 0 {
		for _, e := range m.Branches {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepoAuthInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccessLevel != 0 {
		n += 1 + sovPfs(uint64(m.AccessLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitOrigin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovPfs(uint64(m.Kind))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Commit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lower != nil {
		l = m.Lower.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Upper != nil {
		l = m.Upper.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitProvenance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.ParentCommit != nil {
		l = m.ParentCommit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Finished != nil {
		l = m.Finished.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	if m.Tree != nil {
		l = m.Tree.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Subvenance) > 0 {
		for _, e := range m.Subvenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if len(m.ChildCommits) > 0 {
		for _, e := range m.ChildCommits {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.ReadyProvenance != 0 {
		n += 1 + sovPfs(uint64(m.ReadyProvenance))
	}
	if len(m.Trees) > 0 {
		for _, e := range m.Trees {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.Datums != nil {
		l = m.Datums.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 2 + l + sovPfs(uint64(l))
		}
	}
	if m.Origin != nil {
		l = m.Origin.Size()
		n += 2 + l + sovPfs(uint64(l))
	}
	if m.SubvenantCommitsSuccess != 0 {
		n += 2 + sovPfs(uint64(m.SubvenantCommitsSuccess))
	}
	if m.SubvenantCommitsFailure != 0 {
		n += 2 + sovPfs(uint64(m.SubvenantCommitsFailure))
	}
	if m.SubvenantCommitsTotal != 0 {
		n += 2 + sovPfs(uint64(m.SubvenantCommitsTotal))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.FileType != 0 {
		n += 1 + sovPfs(uint64(m.FileType))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	if len(m.Children) > 0 {
		for _, s := range m.Children {
			l = len(s)
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if len(m.BlockRefs) > 0 {
		for _, e := range m.BlockRefs {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.Committed != nil {
		l = m.Committed.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ByteRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lower != 0 {
		n += 1 + sovPfs(uint64(m.Lower))
	}
	if m.Upper != 0 {
		n += 1 + sovPfs(uint64(m.Upper))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.BlockRef != nil {
		l = m.BlockRef.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Compaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InputPrefixes) > 0 {
		for _, s := range m.InputPrefixes {
			l = len(s)
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Shard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Compaction != nil {
		l = m.Compaction.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.OutputPath)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PathRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Lower)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Upper)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateRepoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Update {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectRepoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListRepoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListRepoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RepoInfo) > 0 {
		for _, e := range m.RepoInfo {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteRepoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.All {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Parent != nil {
		l = m.Parent.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuildCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Parent != nil {
		l = m.Parent.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Tree != nil {
		l = m.Tree.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if len(m.Trees) > 0 {
		for _, e := range m.Trees {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.Datums != nil {
		l = m.Datums.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Finished != nil {
		l = m.Finished.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FinishCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Tree != nil {
		l = m.Tree.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Empty {
		n += 2
	}
	if len(m.Trees) > 0 {
		for _, e := range m.Trees {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	if m.Datums != nil {
		l = m.Datums.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.BlockState != 0 {
		n += 1 + sovPfs(uint64(m.BlockState))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.To != nil {
		l = m.To.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovPfs(uint64(m.Number))
	}
	if m.Reverse {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CommitInfo) > 0 {
		for _, e := range m.CommitInfo {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateBranchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Head != nil {
		l = m.Head.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.SBranch)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectBranchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListBranchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Reverse {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteBranchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlushCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Commits) > 0 {
		for _, e := range m.Commits {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if len(m.ToRepos) > 0 {
		for _, e := range m.ToRepos {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscribeCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPfs(uint64(m.State))
	}
	if m.Prov != nil {
		l = m.Prov.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.OffsetBytes != 0 {
		n += 1 + sovPfs(uint64(m.OffsetBytes))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OverwriteIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovPfs(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Recursive {
		n += 2
	}
	if m.Delimiter != 0 {
		n += 1 + sovPfs(uint64(m.Delimiter))
	}
	if m.TargetFileDatums != 0 {
		n += 1 + sovPfs(uint64(m.TargetFileDatums))
	}
	if m.TargetFileBytes != 0 {
		n += 1 + sovPfs(uint64(m.TargetFileBytes))
	}
	if m.OverwriteIndex != nil {
		l = m.OverwriteIndex.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.HeaderRecords != 0 {
		n += 1 + sovPfs(uint64(m.HeaderRecords))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutFileRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	l = len(m.ObjectHash)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.OverwriteIndex != nil {
		l = m.OverwriteIndex.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.BlockRef != nil {
		l = m.BlockRef.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutFileRecords) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Split {
		n += 2
	}
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.Tombstone {
		n += 2
	}
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Footer != nil {
		l = m.Footer.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CopyFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Dst != nil {
		l = m.Dst.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Overwrite {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Full {
		n += 2
	}
	if m.History != 0 {
		n += 1 + sovPfs(uint64(m.History))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WalkFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GlobFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Pattern)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FileInfo) > 0 {
		for _, e := range m.FileInfo {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiffFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewFile != nil {
		l = m.NewFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.OldFile != nil {
		l = m.OldFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Shallow {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiffFileResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NewFiles) > 0 {
		for _, e := range m.NewFiles {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if len(m.OldFiles) > 0 {
		for _, e := range m.OldFiles {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FsckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fix {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FsckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fix)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileInfoNewStorage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutTarRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTarRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTarConditionalRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Skip {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTarConditionalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileInfo != nil {
		l = m.FileInfo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Eof {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutObjectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateObjectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.BlockRef != nil {
		l = m.BlockRef.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetObjectsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.OffsetBytes != 0 {
		n += 1 + sovPfs(uint64(m.OffsetBytes))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	if m.TotalSize != 0 {
		n += 1 + sovPfs(uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlocksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BlockRefs) > 0 {
		for _, e := range m.BlockRefs {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.OffsetBytes != 0 {
		n += 1 + sovPfs(uint64(m.OffsetBytes))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	if m.TotalSize != 0 {
		n += 1 + sovPfs(uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TagObjectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListObjectsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListTagsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.IncludeObject {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListTagsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteObjectsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteObjectsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteTagsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteTagsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckObjectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckObjectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exists {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Objects) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutObjDirectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Obj)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetObjDirectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Obj)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for k, v := range m.Objects {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPfs(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPfs(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPfs(uint64(mapEntrySize))
		}
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPfs(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPfs(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPfs(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPfs(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPfs(x uint64) (n int) {
	return sovPfs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Repo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Repo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Repo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Branch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Branch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Branch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BranchInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BranchInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BranchInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Head == nil {
				m.Head = &Commit{}
			}
			if err := m.Head.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &Branch{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subvenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subvenance = append(m.Subvenance, &Branch{})
			if err := m.Subvenance[len(m.Subvenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectProvenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectProvenance = append(m.DirectProvenance, &Branch{})
			if err := m.DirectProvenance[len(m.DirectProvenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BranchInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BranchInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BranchInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BranchInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BranchInfo = append(m.BranchInfo, &BranchInfo{})
			if err := m.BranchInfo[len(m.BranchInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Created == nil {
				m.Created = &types.Timestamp{}
			}
			if err := m.Created.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthInfo == nil {
				m.AuthInfo = &RepoAuthInfo{}
			}
			if err := m.AuthInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branches = append(m.Branches, &Branch{})
			if err := m.Branches[len(m.Branches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoAuthInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoAuthInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoAuthInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessLevel", wireType)
			}
			m.AccessLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessLevel |= auth.Scope(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitOrigin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitOrigin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitOrigin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= OriginKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lower == nil {
				m.Lower = &Commit{}
			}
			if err := m.Lower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Upper == nil {
				m.Upper = &Commit{}
			}
			if err := m.Upper.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitProvenance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitProvenance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitProvenance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParentCommit == nil {
				m.ParentCommit = &Commit{}
			}
			if err := m.ParentCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = &types.Timestamp{}
			}
			if err := m.Started.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Finished == nil {
				m.Finished = &types.Timestamp{}
			}
			if err := m.Finished.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tree", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tree == nil {
				m.Tree = &Object{}
			}
			if err := m.Tree.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subvenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subvenance = append(m.Subvenance, &CommitRange{})
			if err := m.Subvenance[len(m.Subvenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildCommits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildCommits = append(m.ChildCommits, &Commit{})
			if err := m.ChildCommits[len(m.ChildCommits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadyProvenance", wireType)
			}
			m.ReadyProvenance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadyProvenance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trees = append(m.Trees, &Object{})
			if err := m.Trees[len(m.Trees)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datums == nil {
				m.Datums = &Object{}
			}
			if err := m.Datums.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &CommitProvenance{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Origin == nil {
				m.Origin = &CommitOrigin{}
			}
			if err := m.Origin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubvenantCommitsSuccess", wireType)
			}
			m.SubvenantCommitsSuccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubvenantCommitsSuccess |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubvenantCommitsFailure", wireType)
			}
			m.SubvenantCommitsFailure = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubvenantCommitsFailure |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubvenantCommitsTotal", wireType)
			}
			m.SubvenantCommitsTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubvenantCommitsTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= FileType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &Object{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockRefs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockRefs = append(m.BlockRefs, &BlockRef{})
			if err := m.BlockRefs[len(m.BlockRefs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Committed == nil {
				m.Committed = &types.Timestamp{}
			}
			if err := m.Committed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ByteRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ByteRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ByteRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			m.Lower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			m.Upper = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Upper |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &ByteRange{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Object{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockRef == nil {
				m.BlockRef = &BlockRef{}
			}
			if err := m.BlockRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Compaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Compaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Compaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputPrefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputPrefixes = append(m.InputPrefixes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Compaction == nil {
				m.Compaction = &Compaction{}
			}
			if err := m.Compaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &PathRange{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lower = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Upper = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateRepoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateRepoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateRepoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Update = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectRepoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectRepoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectRepoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRepoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRepoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRepoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRepoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRepoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRepoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoInfo = append(m.RepoInfo, &RepoInfo{})
			if err := m.RepoInfo[len(m.RepoInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRepoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRepoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRepoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parent == nil {
				m.Parent = &Commit{}
			}
			if err := m.Parent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &CommitProvenance{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parent == nil {
				m.Parent = &Commit{}
			}
			if err := m.Parent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tree", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tree == nil {
				m.Tree = &Object{}
			}
			if err := m.Tree.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &CommitProvenance{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trees = append(m.Trees, &Object{})
			if err := m.Trees[len(m.Trees)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datums == nil {
				m.Datums = &Object{}
			}
			if err := m.Datums.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = &types.Timestamp{}
			}
			if err := m.Started.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Finished == nil {
				m.Finished = &types.Timestamp{}
			}
			if err := m.Finished.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tree", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tree == nil {
				m.Tree = &Object{}
			}
			if err := m.Tree.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Empty = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trees = append(m.Trees, &Object{})
			if err := m.Trees[len(m.Trees)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datums == nil {
				m.Datums = &Object{}
			}
			if err := m.Datums.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockState", wireType)
			}
			m.BlockState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockState |= CommitState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &Commit{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &Commit{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitInfo = append(m.CommitInfo, &CommitInfo{})
			if err := m.CommitInfo[len(m.CommitInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateBranchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateBranchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateBranchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Head == nil {
				m.Head = &Commit{}
			}
			if err := m.Head.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SBranch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &Branch{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectBranchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectBranchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectBranchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListBranchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListBranchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListBranchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteBranchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteBranchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteBranchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlushCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlushCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlushCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commits = append(m.Commits, &Commit{})
			if err := m.Commits[len(m.Commits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToRepos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToRepos = append(m.ToRepos, &Repo{})
			if err := m.ToRepos[len(m.ToRepos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &Commit{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= CommitState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prov", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prov == nil {
				m.Prov = &CommitProvenance{}
			}
			if err := m.Prov.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetBytes", wireType)
			}
			m.OffsetBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OverwriteIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OverwriteIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OverwriteIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recursive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Recursive = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delimiter", wireType)
			}
			m.Delimiter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delimiter |= Delimiter(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetFileDatums", wireType)
			}
			m.TargetFileDatums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetFileDatums |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetFileBytes", wireType)
			}
			m.TargetFileBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetFileBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverwriteIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OverwriteIndex == nil {
				m.OverwriteIndex = &OverwriteIndex{}
			}
			if err := m.OverwriteIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderRecords", wireType)
			}
			m.HeaderRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeaderRecords |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutFileRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutFileRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutFileRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverwriteIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OverwriteIndex == nil {
				m.OverwriteIndex = &OverwriteIndex{}
			}
			if err := m.OverwriteIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockRef == nil {
				m.BlockRef = &BlockRef{}
			}
			if err := m.BlockRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutFileRecords) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutFileRecords: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutFileRecords: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Split", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Split = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &PutFileRecord{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tombstone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tombstone = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &PutFileRecord{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Footer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Footer == nil {
				m.Footer = &PutFileRecord{}
			}
			if err := m.Footer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CopyFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CopyFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CopyFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &File{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dst == nil {
				m.Dst = &File{}
			}
			if err := m.Dst.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overwrite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Overwrite = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Full", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Full = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field History", wireType)
			}
			m.History = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.History |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalkFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalkFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalkFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileInfo = append(m.FileInfo, &FileInfo{})
			if err := m.FileInfo[len(m.FileInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiffFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiffFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiffFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewFile == nil {
				m.NewFile = &File{}
			}
			if err := m.NewFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OldFile == nil {
				m.OldFile = &File{}
			}
			if err := m.OldFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shallow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shallow = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiffFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiffFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiffFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewFiles = append(m.NewFiles, &FileInfo{})
			if err := m.NewFiles[len(m.NewFiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldFiles = append(m.OldFiles, &FileInfo{})
			if err := m.OldFiles[len(m.OldFiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fix", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fix = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileInfoNewStorage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInfoNewStorage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInfoNewStorage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutTarRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutTarRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutTarRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTarRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTarRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTarRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTarConditionalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTarConditionalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTarConditionalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Skip = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTarConditionalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTarConditionalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTarConditionalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileInfo == nil {
				m.FileInfo = &FileInfoNewStorage{}
			}
			if err := m.FileInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eof", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eof = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutObjectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutObjectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutObjectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateObjectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateObjectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateObjectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Object{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockRef == nil {
				m.BlockRef = &BlockRef{}
			}
			if err := m.BlockRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetObjectsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetObjectsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetObjectsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &Object{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetBytes", wireType)
			}
			m.OffsetBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlocksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlocksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlocksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockRefs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockRefs = append(m.BlockRefs, &BlockRef{})
			if err := m.BlockRefs[len(m.BlockRefs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetBytes", wireType)
			}
			m.OffsetBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagObjectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagObjectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagObjectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Object{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListObjectsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListObjectsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListObjectsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTagsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTagsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTagsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeObject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeObject = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTagsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTagsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTagsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tag == nil {
				m.Tag = &Tag{}
			}
			if err := m.Tag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Object{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteObjectsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteObjectsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteObjectsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &Object{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteObjectsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteObjectsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteObjectsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteTagsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteTagsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteTagsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteTagsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteTagsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteTagsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckObjectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckObjectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckObjectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Object{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckObjectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckObjectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckObjectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exists = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Objects) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Objects: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Objects: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &Object{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutObjDirectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutObjDirectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutObjDirectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Obj = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetObjDirectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetObjDirectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetObjDirectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Obj = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Objects == nil {
				m.Objects = make(map[string]*BlockRef)
			}
			var mapkey string
			var mapvalue *BlockRef
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPfs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPfs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPfs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPfs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPfs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPfs
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPfs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BlockRef{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPfs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPfs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Objects[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]*Object)
			}
			var mapkey string
			var mapvalue *Object
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPfs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPfs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPfs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPfs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPfs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPfs
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPfs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Object{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPfs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPfs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPfs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPfs
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPfs
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPfs
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPfs        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPfs          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPfs = fmt.Errorf("proto: unexpected end of group")
)
